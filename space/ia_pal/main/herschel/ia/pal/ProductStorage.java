/* $Id: ProductStorage.java,v 1.53 2008/11/02 15:08:15 bli Exp $ * Copyright (c) 2007 ESA, STFC */package herschel.ia.pal;import herschel.ia.dataset.MetaData;import herschel.ia.dataset.Product;import herschel.ia.pal.ingest.ProductIngester;import herschel.ia.pal.ingest.ProductIngesterParam;import herschel.ia.pal.query.StorageQuery;import herschel.ia.pal.util.ArraySet;import herschel.ia.pal.util.ClassComparator;import herschel.ia.pal.util.UrnUtils;import herschel.ia.pal.util.Util;import herschel.ia.pal.versioning.AbstractVersionProduct;import herschel.share.util.Configuration;import herschel.share.util.ConfigurationException;import java.io.IOException;import java.security.GeneralSecurityException;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.NoSuchElementException;import java.util.Set;import java.util.TreeSet;import java.util.logging.Logger;/** * Provides common access to save, load and query operations for all registered * {@link ProductPool}s. * <p> * <b>Design note:</b>It is common that such operations need to be applied to * more than one pool in a session (for example, a local pool used by an * Astronomer in his session, and a pool connected to the Herschel Science * Archive). Therefore, the design implemented is to separate these operations * from the ProductPool implementations themselves. Users simply need to * register the pools they wish to operate on to a ProductStorage instance, and * use the methods ProductStorage instance to apply operations to those pools. * </p> *  * This is <b>the</b> class that users should use to perform save/load/query * operations on stored products. Some rudimentary operations are possible on * individual pools, but the most enhanced versions of those operations are only * available from the ProductStorage (such us versioning and tagging, saving of *  * context 'trees', context cloning, etc.). * </p> * <p> * Example jython code: Here is a (Jython) example of its usage: *  * <pre> *       # creation *  *       pool = PoolManager.getPool(&quot;myPool&quot;)  # see PoolManager for details *       storage = ProductStorage() *       storage.register(pool) # first pool registered is also used for saving *        *       # load a product reference: *       ref = storage.load(&quot;urn:myPool:herschel.ia.dataset.Product:123&quot;); *        *       # save a product (in this case an empty one), returning a product reference *       ref = storage.save(Product()) *        * </pre> *  * </p> *  * <p> * In addition to save operations for individual products, a ProductStorage * class can also save a 'tree' of {@link Context}s, and copy (clone) a context * tree from one storage to another. * </p> *  *  * @author DP Development Team *  * @jhelp The ProductStorage is a storage mechanism to provide read, write and *        query on Products stored in registered Product Pools. * @jcategory herschel.ia.pal; * @jref herschel.ia.pal.urm * @jexample creation and registering myStore=ProductStorage() *           myStore.register(SimplePool.getInstance()) # the simple.default *           pool *  * @jexample loading a Product from this store *           ref=myStore.load("urn:simple.default:herschel.ia.dataset.Product:123") *  * @jexample saving a Product product=Product(...) ref=myStorage.save(product) *  * @jexample select Products based on a query query=AttribQuery(....) *           results=myStorage.select(query) *  */public class ProductStorage {	@SuppressWarnings("unused")	private static Logger LOG = Logger			.getLogger(ProductStorage.class.getName());	// Whether the shared mode is in place or not	private static boolean _sharedMode;	// Registered pools	private ArraySet<ProductPool> _pools = new ArraySet<ProductPool>(true);	// These handle versions and tags respectively	private VersionHandler _version = HandlerFactory.getVersionHandler(this);	private TagsHandler _tagging = HandlerFactory.getTagsHandler(this);	// This is used to execute a query on each pool and merge the results.	private BasicStorageQueryVisitor _queryVisitor = new BasicStorageQueryVisitor(			this);	// Maps old to new urns when cloning a context.	// I'm not completely sure what this is for, but it gets used in the	// writeDataset	// methods of the contexts.	private Map<String, String> _cloningInfo;	private List<ProductVisitor> _visitorList = new ArrayList<ProductVisitor>();	static {		try {			final String property = "hcss.ia.pal.sharedMode";			_sharedMode = Configuration.getBoolean(property);		} catch (ConfigurationException e) {			_sharedMode = false;		}		LOG.info("Shared mode is " + _sharedMode);	}	/**	 * Creates an empty ProductStorage with no pools registered.	 * 	 * @jhelp Creates an empty ProductStorage with no pools registered.	 */	public ProductStorage() {	}	/**	 * 	 * Creates a ProductStorage with the given pool registered, which	 * 	 * happens to be the writable one.	 * 	 * @jhelp Creates a ProductStorage with the given pool registered, which	 * 	 * happens to be the writable one.	 * 	 * @jexample Creating a storage initialized with a pool.	 * 	 * storage = ProductStorage(pool) # pool is the writable one	 * 	 */	public ProductStorage(ProductPool pool) {		register(pool);	}	/**	 * 	 * Creates a ProductStorage with the given pools registered.	 * <p>	 * 	 * The first provided pool is the writable one.	 * <p>	 * 	 * <em>Java</em>	 * 	 * <pre>	 * ProductStorage storage = new ProductStorage(pool1, pool2, pool3);	 * 	 * </pre>	 * 	 * <em>Jython</em>	 * 	 * <pre>	 * 	 * storage = ProductStorage([pool1, pool2, pool3])  # note the brackets	 * 	 * </pre>	 * 	 * @jhelp Creates a ProductStorage with the given pools registered.	 * 	 * The first provided pool is the writable one.	 * 	 * @jexample Creating a storage initialized with pools.	 * 	 * pool1 = PoolManager.getPool("pool1")	 * 	 * pool2 = PoolManager.getPool("pool2")	 * 	 * pool3 = PoolManager.getPool("pool3")	 * 	 * storage = ProductStorage([pool1, pool2, pool3]) # pool1 is the writable	 * one	 * 	 */	public ProductStorage(ProductPool... pools) {		register(pools);	}	/**	 * 	 * Creates a ProductStorage with the pool corresponding to the given name.	 * 	 * This pool is the writable one.	 * 	 * <p>	 * 	 * The pool is read through the PoolManager, so calling this constructor	 * 	 * like this (Jython):	 * 	 * <pre>	 * 	 * storage = ProductStorage(&quot;pool&quot;)	 * 	 * </pre>	 * 	 * is equivalent to:	 * 	 * <pre>	 * 	 * pool = PoolManager.getPool(&quot;pool&quot;)	 * 	 * storage = ProductStorage(pool)	 * 	 * </pre>	 * 	 * @jhelp Creates a ProductStorage with the the pools corresponding to the	 * 	 * given name.	 * 	 * This pool is the writable one.	 * 	 * @jexample Creating a storage initialized with pools. # the following line	 * 	 * storage = ProductStorage("pool") # is equivalent to	 * 	 * pool = PoolManager.getPool("pool")	 * 	 * storage = ProductStorage(pool)	 * 	 */	public ProductStorage(String poolName) {		register(PoolManager.getPool(poolName));	}	/**	 * 	 * Creates a ProductStorage with the pools corresponding to the given names	 * 	 * registered.	 * <p>	 * 	 * The first provided pool is the writable one.	 * <p>	 * 	 * The pools are read through the PoolManager, so calling this constructor	 * 	 * like this (Jython):	 * 	 * <pre>	 * 	 * storage = ProductStorage([&quot;pool1&quot;, &quot;pool2&quot;, &quot;pool3&quot;])	 * 	 * </pre>	 * 	 * is equivalent to:	 * 	 * <pre>	 * 	 * pool1 = PoolManager.getPool(&quot;pool1&quot;)	 * 	 * pool2 = PoolManager.getPool(&quot;pool2&quot;)	 * 	 * pool3 = PoolManager.getPool(&quot;pool3&quot;)	 * 	 * storage = ProductStorage([pool1, pool2, pool3])	 * 	 * </pre>	 * 	 * @jhelp Creates a ProductStorage with the the pools corresponding to the	 * 	 * given names registered.	 * 	 * The first provided pool is the writable one.	 * 	 * @jexample Creating a storage initialized with pools. # the following line	 * 	 * storage = ProductStorage(["pool1", "pool2", "pool3"]) # is equivalent to	 * 	 * pool1 = PoolManager.getPool("pool1")	 * 	 * pool2 = PoolManager.getPool("pool2")	 * 	 * pool3 = PoolManager.getPool("pool3")	 * 	 * storage = ProductStorage([pool1, pool2, pool3])	 * 	 */	public ProductStorage(String... poolNames) {		for (String poolName : poolNames) {			register(PoolManager.getPool(poolName));		}	}	/**	 * Informs whether different clients have shared access to the pools,	 * 	 * which imply reloading common information (like tags) each time it	 * 	 * is accessed.	 * </p>	 * 	 * This returns false (fast mode) by default, which is the normal behaviour	 * when working with a stand-alone storage.	 */	public static boolean isSharedMode() {		return _sharedMode;	}	/**	 * Sets whether different clients have shared access to the pools,	 * 	 * which imply reloading common information (like tags) each time it	 * 	 * is accessed.	 * <p>	 * This can be set also in the initialization of the application, through	 * the property <code>herschel.ia.pal.updateVersionInfo</code>.	 * 	 * @jhelp Sets whether the last version info is to be updated before each	 *        operation on the storage. Set it to <code>true</code> if you	 *        expect any other ProductStorage may update the products from the	 *        outside.	 *        <p>	 *        This can be set also in the initialization of the application, by	 *        the property <code>hcss.ia.pal.sharedMode</code>.	 * 	 * @jparameter sharedMode, INPUT, boolean, MANDATORY Whether the storage is	 *             accessed for writing by several processes at the same time.	 */	public static void setSharedMode(boolean sharedMode) {		_sharedMode = sharedMode;	}	/**	 * 	 * Registers a pool to the storage. The first	 * 	 * ProductPool will be the one for which save operations would	 * 	 * write products to. The remaining pools registered will be read-only.	 * 	 * 	 * 	 * @jhelp Registers a ProductPool to the ProductStorage. The first	 * 	 * ProductPool will be the one for which save operations would write	 * 	 * products to. The remaining pools registered will be read-only.	 * 	 * 	 * 	 * @jparameter pool, INPUT, ProductPool, MANDATORY The product pool that	 * 	 * will be added to this product storage.	 * 	 * 	 * 	 * @jexample How to register a product pool	 * 	 * storage.register(pool)	 * 	 */	public void register(ProductPool pool) {		_pools.add(pool);	}	/**	 * Registers the given pools to the storage. The first ProductPool will be	 * the one for which save operations would write products to. The remaining	 * pools registered will be read-only.	 * 	 * 	 * @jhelp Registers ProductPools to the ProductStorage. The first	 *        ProductPool will be the one for which save operations would write	 *        products to. The remaining pools registered will be read-only.	 * 	 * @jparameter pools, INPUT, ProductPool array, MANDATORY The product pools	 *             that will be added to this product storage.	 * 	 * 	 * 	 * @jexample How to register many pools at the same time	 * 	 * storage.register([pool1, pool2, pool3])	 */	public void register(ProductPool... pools) {		_pools.addAll(Arrays.asList(pools));	}	/**	 * 	 * Returns the set of ProductPools registered.	 * 	 * <p>	 * 	 * The ordering of the set is consistent with the ordering of the	 * 	 * ProductPools registered to the storage; ie the first pool registered is	 * 	 * the first pool in the set.	 * 	 * </p>	 * 	 * 	 * 	 * @jhelp Provides the set of ProductPools registered, in order in which	 * 	 * they were initially registered.	 * 	 */	public Set<ProductPool> getPools() {		return _pools;	}	/**	 * Returns the writable pool, which is the first registered pool.	 * 	 * @jhelp Returns the writable pool, which is the first registered pool.	 */	public ProductPool getWritablePool() {		checkPools();		return _pools.get(0);	}	/**	 * 	 * Add a visitor, which is executed on every product, before it is	 * committed.	 * 	 */	public void addVisitor(ProductVisitor visitor) {		_visitorList.add(visitor);	}	/**	 * 	 * Remove visitor from list of visitors executed before commit.	 * 	 * 	 * 	 * @return true, if the visitor was in the list of visitor, false otherwise.	 * 	 */	public boolean removeVisitor(ProductVisitor visitor) {		return _visitorList.remove(visitor);	}	/**	 * Yields all Product classes found in this pool.	 * 	 * @return a collection of Product classes	 * 	 * @jhelp Provides all Product class definitions found in this pool.	 * @jalias productClasses	 * @jreturn a collection of Product classes	 */	public Set<Class<? extends Product>> getProductClasses()			throws IOException, GeneralSecurityException {		Set<Class<? extends Product>> classes;		classes = new TreeSet<Class<? extends Product>>(new ClassComparator());		for (ProductPool pool : _pools) {			classes.addAll(pool.getProductClasses());		}		return classes;	}	/**	 * Removes a product of given URN from the storage. Note that this can only	 * remove data from the writable pool.	 * 	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws IllegalArgumentException	 *             if the urn supplied is null	 * 	 * @throws NoSuchElementException	 *             if the urn does not belong to the writable pool.	 * @throws GeneralSecurityException	 *             if it is not permissable for that user to remove a product of	 *             that urn from the pool.	 * @jhelp Removes a product of given URN from the storage.	 * @jparameter urn, INPUT, String, MANDATORY The URN to the Product that	 *             should be removed.	 */	public void remove(String urn) throws IOException, GeneralSecurityException {		_tagging.removeUrn(urn);		_version.removeUrn(urn);		getWritablePool().remove(urn);	}	/**	 * When recursive is true and the urn refer to an Context, all products linked to it will be removed. 	 * SPR-5204	 * @param urn	 * @param recursive	 * @throws IOException	 * @throws GeneralSecurityException	 */	public void remove(String urn, boolean recursive) throws IOException,			GeneralSecurityException {		System.out.println("remove: " + urn);		ProductRef ref = this.load(urn);		if (recursive) {			if (Context.isContext(ref.getProduct().getClass())) {				Set<ProductRef> all = ((Context)ref.getProduct()).getAllRefs();				for(ProductRef pRef:all){					String pUrn = pRef.getUrn();					remove(pUrn, true);				}			}		} 		remove(urn);	}		/**	 * 	 * @param ingester	 * @param param	 */	public void ingest(ProductIngester ingester, ProductIngesterParam param){		ingester.ingest(this, param);	}		/**	 * Check whether a product is present in the pool.	 * 	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws GeneralSecurityException	 *             if it is not permissible for the user to read from this pool.	 */	boolean exists(String urn) throws IOException, GeneralSecurityException {		for (ProductPool pool : _pools) {			if (pool.exists(urn))				return true;		}		return false;	}	/**	 * Loads a product from the ProductStorage.	 * 	 * @param id	 *            the URN or tag to the product being loaded.	 * @return a reference to the Product corresponding to the input URN.	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws IllegalArgumentException	 *             if the identifier is null	 * @throws NoSuchElementException	 *             if the urn is not found in the registered pools.	 * 	 * @throws GeneralSecurityException	 *             if it is not permissable for that user	 * 	 * to load a product of that urn from the pool.	 * @jhelp Loads a Product from this store.	 * @jparameter id, INPUT, String, MANDATORY The URN or tag to the Product	 * @jreturn A reference to the Product corresponding to the input URN or	 *          tag.	 */	public ProductRef load(String id)	throws IOException, GeneralSecurityException {		if (id == null) {			throw new IllegalArgumentException("Identifier must not be null.");		}		String urn = UrnUtils.isUrn(id) ? id : _tagging.getUrn(id);		if (!exists(urn)) {			throw new NoSuchElementException(urn + " not found in storage");		}		return new ProductRef(this, urn);	}	/**	 * Loads a product from the ProductStorage.	 * 	 * @param urn	 *            the URN to the product being loaded.	 * @return the product corresponding to the input URN. in future	 *         implementations, the returned object will be of type	 *         {@link ProductRef}.	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws IllegalArgumentException	 *             if the URN is null or corresponds to a pool not registered to	 *             this ProductStorage	 */	Product loadProduct(ProductRef ref) throws IOException,			GeneralSecurityException {		checkPools();		String urn = ref.getUrn();		ProductPool pool = UrnUtils.getPool(urn, _pools);		Product product = pool.loadProduct(urn);		if (!ref.hasLoadedDescriptors()) {// avoid calling UrnUtils.getPool			// again			ref.setDescriptors(pool.loadDescriptors(urn));		}		if (ref.hasTrack()) {			String trackId = ref.getTrackId();			int version = ref.getVersion();			product					.setOwner(new ProductVersion(this, product, trackId,							version));		}		/* BACKWARDS COMPATIBILITY. TODO: REMOVE */		MetaData meta = product.getMeta();		if (meta.containsKey("versionTrack")) {			meta.remove("versionTrack");			meta.remove("versionNumber");		}		/* END BACKWARDS COMPATIBILITY */		// make the additional changes to contexts		if (product instanceof Context) {			((Context) product).load(this, urn);		}		return product;	}	/**	 * Get the meta data for a given product.	 */	MetaData loadMeta(String urn) throws IOException, GeneralSecurityException {		checkPools();		// Try to obtain the meta data for any stored pool. Avoid using		// UrnUtils.getPool, because it calls exists unnecessarily for DbPools.		for (ProductPool pool : _pools) {			try {				return pool.meta(urn);			} catch (NoSuchElementException e) { /* try the following pool */			}		}		throw new NoSuchElementException("No such urn in storage " + _pools				+ ": " + urn);	}	/**	 * 	 * Get the descriptors for a given product.	 * 	 */	Map<String, Object> loadDescriptors(String urn) throws IOException,			GeneralSecurityException {		checkPools();		ProductPool pool = UrnUtils.getPool(urn, _pools);		return pool.loadDescriptors(urn);	}	/**	 * Assigns (or re-assigns) a tag to a URN. This method requires an absolute	 * URN as the second argument (ie, not a tag). It throws	 * IllegalArgumentException if the URN is not absolute (ie, a tag. An	 * absolute urn has the form urn:pool:Product:1234)	 * 	 * @throws IllegalArgumentException	 *             if the tag or the urn are not valid	 */	public void setTag(String tag, String urn)	throws IOException, GeneralSecurityException {		setTag(tag, urn, true);	}	/**	 * 	 * Assigns (or re-assigns) a tag to a URN.	 * 	 * This method requires an absolute URN as the second argument (ie, not a	 * 	 * tag). It throws IllegalArgumentException if the URN is not absolute (ie,	 * 	 * a tag. An absolute urn has the form urn:pool:Product:1234)	 * 	 * @throws IllegalArgumentException	 *             if the URN is not absolute	 * 	 * (ie, a tag. An absolute urn has the form urn:pool:Product:1234)	 * 	 */	private void setTag(String tag, String urn, boolean checkUrnExists)	throws IOException, GeneralSecurityException {		UrnUtils.checkUrn(urn);		if (checkUrnExists && !exists(urn)) {			String message = "urn not existing in '" + this + "': " + urn;			throw new NoSuchElementException(message);		}		_tagging.setTag(tag, urn);	}	/**	 * Saves a product to the storage.	 * <p>	 * If the product is a context that has descendents, all its descendents	 * 	 * will be copied if they do not already exist in the destination storage	 * 	 * (this is a deep-copy or cloning operation).	 * </p>	 * 	 * <p>	 * Note that this method doesn't save previous versions of the product,	 * 	 * even if they do not exist in the target pool: it just saves this actual	 * 	 * version.	 * </p>	 * 	 * <p>	 * If saving all versions of the product is wanted, it has to be done	 * 	 * explicitly, with code like the following one:	 * </p>	 * 	 * <p>	 * <em>Java</em>	 * </p>	 * 	 * <pre>	 * 	 * List&lt;ProductRef&gt; versions = storage1.getVersions(ref);	 * 	 * for (ProductRef version : versions) {	 * 	 * 	storage2.save(version);	 * 	 * }	 * 	 * </pre>	 * 	 * <p>	 * <em>Jython</em>	 * </p>	 * 	 * <pre>	 * 	 * versions = storage1.getVersions(ref).iterator()	 * 	 * while versions.hasNext():	 * 	 *     storage2.save(versions.next())	 * 	 * </pre>	 * 	 * 	 * 	 * @param product	 *            the product to be saved.	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws GeneralSecurityException	 *             if it is not permissable for that user to load a product of	 * 	 * that urn from the pool.	 * @jhelp Saves a Product to this store. If the product is a context that	 *        has descendents, all those descendents will be copied if they do	 *        not already exist in the destination storage (this is a deep-copy	 *        or cloning operation).	 * @jparameter product, INPUT, Product, MANDATORY The product that should be	 *             saved.	 * @jreturn A reference to the Product saved into the store.	 */	public ProductRef save(Product product) throws IOException,			GeneralSecurityException {		try {			_cloningInfo = new HashMap<String, String>();			ProductRef ref = new ProductRef(product);			commit(ref);			return ref;		} finally {			_cloningInfo = null; // clean this map after the operation		}	}	/**	 * Saves a product to the storage, but not its versions.	 * <p>	 * If the product is a context that has descendents, all those descendents	 * will be copied if they do not already exist in the destination storage	 * (this is a deep-copy or cloning operation.	 * </p>	 * 	 * @param product	 *            the product to be saved.	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws GeneralSecurityException	 *             if it is not permissable for that user to load a product of	 *             that urn from the pool.	 * @jhelp Saves a Product to this store. If the product is a context that	 *        has descendents, all those descendents will be copied if they do	 *        not already exist in the destination storage (this is a deep-copy	 *        or cloning operation).	 * @jparameter product, INPUT, Product, MANDATORY The product that should be	 *             saved.	 * @jreturn A reference to the Product saved into the store.	 * 	 * @deprecated save saves only the actual product, so use that instead.	 */	public ProductRef saveHeadOnly(Product product) throws IOException,			GeneralSecurityException {		return save(product);	}	/**	 * Save a product to the storage, under the supplied tag. This method allows	 * the user to provide a tag to a given product. If the tag is already in	 * the system (ie a previous product has been assigned with this tag), then	 * the tag will be re-assigned.	 * 	 * @param tag	 * @param p	 * @throws GeneralSecurityException	 * @throws IOException	 */	public ProductRef saveAs(Product p, String tag) throws IOException,			GeneralSecurityException {		ProductRef ref = save(p);		setTag(tag, ref.getUrn(), false);		return ref;	}	/**	 * 	 * Writes data to storage, if the ProductRef is not dirty and the storage	 * 	 * does not already contain the corresponding Product.	 * 	 */	void commit(ProductRef ref) throws IOException, GeneralSecurityException {		// Auxiliary variables		Product product = ref.getProduct();		Util.checkNotNull(product, "product");		boolean findVersion = true;		boolean isLoaded = ref.isLoaded();		boolean isContext = product instanceof Context;		Context context = isContext ? (Context) product : null;		String urn = ref.getUrn();		// Do nothing if the product is already present in the storage		// TODO Check whether a product with the same hash already exists		if (urn != null) {			if (exists(urn)) {				if (!isContext || !context.isDirty(this))					return;			} else {				findVersion = false; // the product doesn't exist in the				// storage			}		}		// Call visitors on this product		for (ProductVisitor visitor : _visitorList) {			product.accept(visitor);		}		// Commit the product		if (!isLoaded)			ref.setProduct(product); // set the product if not done		if (isContext)			context.commitRefs(this); // save children first		urn = _version.save(ref, findVersion); // save this product		if (isContext)			context.committed(urn); // clean-up the context		// SPR-4590		// if (!isLoaded) ref.setProduct(null); // leave things as they were		if (!isContext)			ref.setProduct(null);		// Update the reference		ref.setUrn(urn);		ref.setStorage(this);	}	/**	 * Returns a list of references to products that match the specified query.	 * 	 * @param query	 *            the query object	 * @return the set of ProductRefs to products matching the supplied query.	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws IllegalArgumentException	 *             if the query argument is null or in the wrong format.	 * @throws GeneralSecurityException	 *             if it is not permissible for the user to query this pool.	 * @jhelp Returns a set of references to products that match the specified	 *        query.	 * @jparameter query, INPUT, StorageQuery, MANDATORY The query applied to	 *             this store.	 * @jreturn A set of references to Products selected by the query	 */	public Set<ProductRef> select(StorageQuery query) throws IOException,			GeneralSecurityException {		_queryVisitor.resetResults();		_queryVisitor.resetPrevious();		return execute(query);	}	/**	 * Returns a list of URNs to products that match the specified query.	 * 	 * @param query	 *            the query object	 * @return the set of references to products matching the supplied query.	 * @throws IOException	 *             if an IO operation has failed, eg due to the internet	 *             connection being broken, or due to a corrupted file system	 * @throws IllegalArgumentException	 *             if the query argument is null or in the wrong format.	 * @throws GeneralSecurityException	 *             if it is not permissible for the user to query this pool.	 * @jhelp Returns a set of references to products that match the specified	 *        query.	 * @jparameter query, INPUT, StorageQuery, MANDATORY The query applied to	 *             this store.	 * @jreturn A set of references to Products selected by the query	 */	public Set<ProductRef> select(StorageQuery query, Set<ProductRef> previous)			throws IOException, GeneralSecurityException {		_queryVisitor.resetResults();		_queryVisitor.setPrevious(previous);		return execute(query);	}	private Set<ProductRef> execute(StorageQuery query) throws IOException,			GeneralSecurityException {		LOG.fine("Executing query");		query.accept(_queryVisitor);		LOG.fine("Query complete, consolidating results");		Set<ProductRef> results = _queryVisitor.getResults();		results = consolidateResult(results, query.retrieveAllVersions());		LOG.fine("Finished");		return results;	}	/**	 * Returns either the input result set, or a consolidated result set	 * corresponding to the latest versions of the results only.	 * 	 * TODO It is still done in ProductStorage. Returning latest	 * 	 * refs could be responsibility of each pool. Doing it here has: - the	 * advantage of alleviating processing on pools: they just return	 * 	 * all matches of a given query, without worrying about versions. - the	 * disadvantage of transmitting more references from the server	 * 	 * to the client, in remote pools.	 * 	 */	private Set<ProductRef>	consolidateResult(Set<ProductRef> results, boolean retrieveAllVersions) {		for (ProductRef ref : results) {			ref.setStorage(this);		}		if (!retrieveAllVersions) {			results = getLatest(results);		}		return results;	}	/**	 * 	 * Get the latest versions of ProductRefs from an input super-set.	 * 	 * What is regarded as the 'latest versions' are those that correspond	 * 	 * to the latest version of the version track contained in those products.	 * 	 */	private Set<ProductRef> getLatest(Set<ProductRef> resultSet) {		// Get the last versions of each track, and the products without track		Set<ProductRef> noVersionTrackRefs = new ArraySet<ProductRef>(true);		Map<String, ProductRef> latestProducts = new HashMap<String, ProductRef>();		for (ProductRef ref : resultSet) {			// TODO replace by ref.getType().equals(TagsProduct.class)			if (AbstractVersionProduct.class.isAssignableFrom(ref.getType())) {				continue;			}			if (!ref.hasTrack()) {				noVersionTrackRefs.add(ref);				continue;			}			String trackId = ref.getTrackId();			ProductRef refOrig = latestProducts.get(trackId);			if (refOrig == null || refOrig.getVersion() < ref.getVersion()) {				latestProducts.put(trackId, ref);			}		}		Set<ProductRef> outputSet = new ArraySet<ProductRef>();		outputSet.addAll(latestProducts.values());		outputSet.addAll(noVersionTrackRefs);		return outputSet;	}	/**	 * Returns a {@link List} of {@link ProductRef}s corresponding to all the	 * 	 * versions of this {@link Product}, belonging to the first pool where	 * 	 * the same track id is found. The given product then may not be included	 * 	 * in the list, if its track is hidden by a former pool.	 * 	 * <p>	 * The pools are searched in the order they have been registered.	 * 	 */	public List<ProductRef> getVersions(ProductRef ref)	throws IOException, GeneralSecurityException {		return _version.getVersions(ref);	}	/**	 * Returns the latest version of a given product, belonging to the first	 * 	 * pool where the same track id is found.	 * <p>	 * The pools are searched in the order they have been registered.	 * 	 */	public ProductRef getHead(ProductRef ref) throws IOException,			GeneralSecurityException {		return _version.getLastVersion(ref);	}	/**	 * Get the URN belonging to the writable pool that is associated to a given	 * tag.	 * 	 * @throws NoSuchElementException	 *             if the tag is not found in the writable pool	 */	public String getUrnFromTag(String tag) throws IOException,			GeneralSecurityException {		return _tagging.getUrn(tag);	}	/**	 * Get the tags belonging to the writable pool that associated to a given	 * URN.	 */	public Set<String> getTags(String urn) throws IOException,			GeneralSecurityException {		return _tagging.getTags(urn);	}	/**	 * Get all tags defined in the writable pool.	 */	public Set<String> getAllTags() throws IOException,			GeneralSecurityException {		return _tagging.getTags();	}	/**	 * 	 * Tests if a tag exists in the writable pool.	 * 	 * @param tag	 *            to check	 * 	 * @return <code>true</code> if it does	 * 	 */	public boolean tagExists(String tag) throws IOException,			GeneralSecurityException {		return _tagging.tagExists(tag);	}	/**	 * 	 * Removes a tag from the storage. Subsequent access to storage with that	 * 	 * tag would result in a {@link NoSuchElementException}.	 * 	 * @param tag	 * 	 * @throws GeneralSecurityException	 * 	 * @throws IOException	 * 	 * @throws NoSuchElementException	 *             if the tag is not present in the storage.	 * 	 */	public void removeTag(String tag) throws IOException,			GeneralSecurityException {		if (!tagExists(tag)) {			throw new NoSuchElementException("Tag \'" + tag + "\' not found.");		}		_tagging.removeTag(tag);	}	/**	 * Get string representation of version and tags information.	 */	public String getVersioningInfo() {		return _version.toString() + _tagging.toString();	}	/**	 * Returns the mapping between old and new urns when cloning a context.	 */	Map<String, String> getCloningInfo() {		return _cloningInfo;	}	/**	 * Return a summary of this storage as a string.	 * 	 * @return a string indicating the storage contents	 */	@Override	public String toString() {		StringBuilder b = new StringBuilder("[");		for (ProductPool pool : _pools) {			if (b.length() > 1)				b.append(", ");			b.append(pool.getId());		}		b.append("]");		return b.toString();	}	private void checkPools() {		if (_pools == null || _pools.size() == 0)			throw new NoSuchElementException("No product pools registered");	}}