/* $Id: FileUtil.java,v 1.4 2008/03/31 15:59:17 jsaiz Exp $ * Copyright (c) 2007 STFC */package herschel.ia.pal.util;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Enumeration;import java.util.logging.Logger;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;/** * File handling utilities. */public class FileUtil {    private static Logger log = Logger.getLogger(FileUtil.class.getName());    /**     * Delete a directory and all of its contents.     * @param dir directory to delete     * @throws IllegalArgumentException if dir is null, or it is not a directory     */    public static boolean deleteDirectory(File dir) {        return deleteDirectory(dir, true);    }    /**     * Delete a directory and all of its contents, by checking the deletion.     * @param dir directory to delete     * @param checkDeletion <ul><li>if <code>true</code>:     * <ul><li>if dir is null or is not a directory, an IllegalArgumentException is thrown.</li>     * <li>if an internal file or the directory cannot be deleted, a warning is produced.</li>     * </ul>     * <li>if <code>false</code>, these cases are silently ignored.</li></ul>     * @throws IllegalArgumentException if dir is null, it is not a directory,     * and checkDeletion is <code>true</code>.     */    public static boolean deleteDirectory(File dir, boolean checkDeletion) {        if ((dir == null) || !dir.isDirectory()) {            if (checkDeletion) {                throw new IllegalArgumentException(dir +" is not a directory.");            }            return false;        }        for (File file : dir.listFiles()) {            if (file.isDirectory()) {                deleteDirectory(file, checkDeletion);            } else {                deleteFile(file, checkDeletion);            }        }        return deleteFile(dir, checkDeletion);    }    private static boolean deleteFile(File file, boolean checkDeletion) {        boolean deleted = file.delete();        if (!deleted && checkDeletion) {            log.warning(file + " cannot be deleted.");        }        return deleted;    }    /**     * Return the size on disk of the denoted File in bytes. The File can also point to a directory.     * Files in the directory and subdirectories are included.     *      * @param dir     * file or directory     * @return size in bytes     */    public static long getSizeOnDisk(File dir) {	long size = 0; // size in bytes	// A long can count to approx 10^19. 10^19 bytes is approx 10^7 TB.	if (dir.isDirectory()) {	    String[] files = dir.list();	    for (String fileStr : files) {		File file = new File(dir + File.separator + fileStr);		if (file.isDirectory()) {		    size += getSizeOnDisk(file);		} else {		    size += file.length();		}	    }	} else {	    size = dir.length();	}	return size;    }    /**     * Unzip the zipfile in it's current dir.     *      * @param zipFile     * the zipped File     * @throws IOException     */    public static void unzip(File zipFile) throws IOException {	String dataDir = zipFile.getParent();//	String zipFileName = zipFile.getName();	if (zipFile.exists()) {	    ZipFile zippedFile = new ZipFile(zipFile.getAbsolutePath());	    Enumeration entries = zippedFile.entries();	    while (entries.hasMoreElements()) {		ZipEntry entry = (ZipEntry) entries.nextElement();		String out = dataDir + File.separator + entry.getName();		if (entry.isDirectory()) {		    (new File(out)).mkdirs();		    continue;		}		copyInputStream(zippedFile.getInputStream(entry),		                new BufferedOutputStream(new FileOutputStream(out)));	    }	    zippedFile.close();	} else {	    throw new IOException("ZipFile not found. Expected in: " + dataDir);	}    }    private static final void copyInputStream(InputStream in, OutputStream out) throws IOException {	byte[] buffer = new byte[1024];	int len;	while ((len = in.read(buffer)) >= 0)	    out.write(buffer, 0, len);	in.close();	out.close();    }    /**         * Copy a file or directory from source to destination.         *          * @param src         * source file or directory         * @param dest         * target file or directory         * @throws IOException         */    public static void copyFiles(File src, File dest) throws IOException {	if (src.isDirectory()) {	    dest.mkdirs();	    String list[] = src.list();	    for (int i = 0; i < list.length; i++) {		String dest1 = dest.getPath() + File.separator + list[i];		String src1 = src.getPath() + File.separator + list[i];		copyFiles(new File(src1), new File(dest1));	    }	} else {	    FileInputStream fin = new FileInputStream(src);	    FileOutputStream fout = new FileOutputStream(dest);	    int c;	    while ((c = fin.read()) >= 0)		fout.write(c);	    fin.close();	    fout.close();	}    }}