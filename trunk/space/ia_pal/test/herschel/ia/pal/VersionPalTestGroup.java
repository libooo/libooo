/* $Id: VersionPalTestGroup.java,v 1.24 2008/09/12 10:44:27 bli Exp $ * Copyright (c) 2007 ESA, STFC */package herschel.ia.pal;import herschel.ia.dataset.LongParameter;import herschel.ia.dataset.MetaData;import herschel.ia.dataset.Product;import herschel.ia.dataset.StringParameter;import herschel.ia.pal.query.AttribQuery;import herschel.ia.pal.query.FullQuery;import herschel.ia.pal.query.MetaQuery;import herschel.ia.pal.query.Query;import herschel.ia.pal.query.StorageQuery;import herschel.ia.pal.versioning.TagsProduct;import herschel.ia.pal.versioning.TestProduct;import herschel.share.util.StackTrace;import java.io.IOException;import java.security.GeneralSecurityException;import java.util.Arrays;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.NoSuchElementException;import java.util.Set;import java.util.logging.Logger;/** * Class that groups all tests about product versioning in PAL. */public class VersionPalTestGroup extends AbstractPalTestGroup {	@SuppressWarnings("unused")	private static final Logger _LOGGER = Logger			.getLogger(VersionPalTestGroup.class.getName());	private static final String _MAPCONTEXT_TYPE = "MapContext";	private static final String _LISTCONTEXT_TYPE = "ListContext";	/** Constructor */	public VersionPalTestGroup(String name, AbstractPalTestCase testcase) {		super(name, testcase);	}	// GENERAL TEST -----------------------------------------------------------	/**	 * Tests the examples in the wiki page about product versioning,	 * http://www.herschel.be/twiki/bin/view/Hcss/ProductVersioningGuide	 */	public void testGeneral() throws IOException, GeneralSecurityException {		ProductStorage storage = new ProductStorage();		storage.register(getPool());		Product edition = new Product();		ProductRef refP0 = storage.save(edition); // version 0 of edition													// saved		edition.getMeta().set("example", new StringParameter("value"));		ProductRef refP1 = storage.save(edition); // version 1 of edition													// saved		assertEquals(storage.getHead(refP0), refP1);		assertEquals(storage.getVersions(refP1), Arrays.asList(refP0, refP1));		MapContext m = new MapContext();		ProductRef refM0 = storage.save(m);		m.getMeta().set("other", new LongParameter(1, "a number"));		ProductRef refM1 = storage.save(m);		assertEquals(storage.getHead(refM0), refM1);		assertEquals(storage.getVersions(refM1), Arrays.asList(refM0, refM1));		AttribQuery query = new AttribQuery(Product.class, "p", "1");		Set<ProductRef> result = storage.select(query); // the latest versions		assertEquals(2, result.size()); // 1 Product, 1 MapContext		query = new AttribQuery(Product.class, "p", "1", true);		result = storage.select(query); // all versions of editions that match		assertEquals(4, result.size()); // 2 Product, 2 MapContext		storage.saveAs(edition, "myTag");		ProductRef refP2 = storage.load("myTag");		assertEquals(storage.getHead(refP0), refP2);		assertEquals(storage.getHead(refP1), refP2);		assertEquals(storage.getVersions(refP0), Arrays.asList(refP0, refP1,				refP2));		result = storage.select(query); // all versions of editions that match		assertEquals(6, result.size()); // 3 Product, 2 MapContext, 1										// TagsProduct		storage.setTag("myTag1", refM0.getUrn());		storage.setTag("myTag2", refM0.getUrn());		storage.setTag("myTag3", refM0.getUrn());		storage.setTag("myTag4", refM0.getUrn());		storage.setTag("myTag4", refM1.getUrn());		assertEquals(refP2, storage.load("myTag"));		assertEquals(refM0, storage.load("myTag1"));		assertEquals(refM0, storage.load("myTag2"));		assertEquals(refM0, storage.load("myTag3"));		assertEquals(refM1, storage.load("myTag4"));		assertTrue(storage.tagExists("myTag"));		assertFalse(storage.tagExists("noTag"));	}	// BASIC COPY VERSIONING TESTS --------------------------------------------	/**	 * In this test there are two product storages, which products of the same	 * type written to the same version track identifier for each. A product of	 * one storage is copied to the other. The result should be that this	 * product should be added as the third and most recent version of that	 * version track.	 */	public void testSimpleProductCloning() {		final String creatorOne = "Creator1";		final String creatorTwo = "Creator2";		final String creatorThree = "Creator3";		final String instrumentOne = "InstrumentOne";		final String instrumentTwo = "InstrumentTwo";		ProductStorage storageOne;		ProductStorage storageTwo;		String lastProductStorageOneUrn;		// Populate storages.		try {			{				storageOne = new ProductStorage();				storageOne.register(getPool(1));				String urn;				{					// Create a product and save it.					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentOne);					urn = storageOne.save(p).getUrn();				}				{					// Load product using given version track					ProductRef r = storageOne.load(urn);					Product p = r.getProduct();					assertTrue(creatorOne.equals(p.getCreator()));				}				{					// Modify and save it again					// This should be added as the latest version of the product					ProductRef r = storageOne.load(urn);					Product p = r.getProduct();					p.setCreator(creatorTwo);					lastProductStorageOneUrn = storageOne.save(p).getUrn();				}			}			// Repeat the same operation, but with a different storage			// Use a different instrument to can distinquish the two separate			// sets of data.			String storageTwoFirstProductUrn;			{				storageTwo = new ProductStorage();				storageTwo.register(getPool(2)); // writable pool				storageTwo.register(getPool(1));				{					// Create a product and save it					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentTwo);					storageTwoFirstProductUrn = storageTwo.save(p).getUrn();				}				{					// Load product using given version track					ProductRef r = storageTwo.load(storageTwoFirstProductUrn);					Product p = r.getProduct();					assertTrue(creatorOne.equals(p.getCreator()));				}				{					// Modify and save it again explicitly under the given					// version track. This should be added as the latest					// version of the product.					ProductRef r = storageTwo.load(storageTwoFirstProductUrn);					Product p = r.getProduct();					p.setCreator(creatorTwo);					storageTwo.save(p);				}			}			{				// Finally, save the last product in storageOne to storageTwo				ProductRef r = storageTwo.load(lastProductStorageOneUrn);				Product p = r.getProduct();				p.setCreator(creatorThree);				storageTwo.save(p);			}			// Check the last version of the version tracks			{				// Product from pool 1				ProductRef r = storageTwo.load(lastProductStorageOneUrn);				ProductRef r_latest = storageTwo.getHead(r);				Product p_latest = r_latest.getProduct();				assertTrue(creatorThree.equals(p_latest.getCreator()));				assertTrue(instrumentOne.equals(p_latest.getInstrument()));			}			{				// Product from pool 2				ProductRef r = storageTwo.load(storageTwoFirstProductUrn);				ProductRef r_latest = storageTwo.getHead(r);				Product p_latest = r_latest.getProduct();				assertTrue(creatorTwo.equals(p_latest.getCreator()));				assertTrue(instrumentTwo.equals(p_latest.getInstrument()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * As above, but with contexts used instead. Each context contains one leaf	 * product. The result should be the same,	 */	public void testSimpleContextCloning() {		final String productkey = "leafproduct";		final String creatorOne = "Creator1";		final String creatorTwo = "Creator2";		final String creatorThree = "Creator3";		final String instrumentOne = "InstrumentOne";		final String instrumentTwo = "InstrumentTwo";		ProductStorage storageOne;		ProductStorage storageTwo;		String lastProductStorageOneUrn;		// Populate storages.		try {			{				storageOne = new ProductStorage();				storageOne.register(getPool(1));				String urn;				{					// Create a product and save it to the storage.					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentOne);					ProductRef r = storageOne.save(p);					// Add it as an entry to a MapContext					MapContext m = new MapContext();					// Set type (as this is needed by the versioning mechanism)					m.setType(_MAPCONTEXT_TYPE);					m.getRefs().put(productkey, r);					// Save the context to the storage					urn = storageOne.save(m).getUrn();				}				{					// Load context using					ProductRef r_m = storageOne.load(urn);					MapContext m = (MapContext) r_m.getProduct();					ProductRef r_p = m.getRefs().get(productkey);					Product p = r_p.getProduct();					assertTrue(creatorOne.equals(p.getCreator()));					// Modify leaf product, add it to the mapcontext					// and save the mapcontext again. This should be added as					// the latest version of the product.					p.setCreator(creatorTwo);					ProductRef r_p2 = storageOne.save(p);					m.getRefs().put(productkey, r_p2);					lastProductStorageOneUrn = storageOne.save(m).getUrn();					// _LOGGER.info(storageOne.getVersioningInfo());				}			}			// Repeat the same operation, but with a different storage			// Use a different instrument to can distinquish the two separate			// sets of data.			String storageTwoFirstProductUrn;			{				storageTwo = new ProductStorage();				storageTwo.register(getPool(2)); // writable pool				storageTwo.register(getPool(1));				{					// Create a product and save it to the storage.					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentTwo);					ProductRef r = storageTwo.save(p);					// Add it as an entry to a MapContext					MapContext m = new MapContext();					m.setType(_MAPCONTEXT_TYPE);					m.getRefs().put(productkey, r);					// Save the context to the storage					storageTwoFirstProductUrn = storageTwo.save(m).getUrn();				}				{					// Load context					ProductRef r_m;					r_m = storageTwo.load(storageTwoFirstProductUrn);					MapContext m = (MapContext) r_m.getProduct();					ProductRef r_p = m.getRefs().get(productkey);					Product p = r_p.getProduct();					assertTrue(creatorOne.equals(p.getCreator()));					// Modify leaf product,					// add it to the mapcontext					// and save the mapcontext again.					// This should be added as the latest version of the					// product.					p.setCreator(creatorTwo);					ProductRef r_p2 = storageTwo.save(p);					m.getRefs().put(productkey, r_p2);					storageTwo.save(m);				}			}			{				// Finally, save the last product in storageOne to storageTwo				ProductRef r_m = storageTwo.load(lastProductStorageOneUrn);				MapContext m = (MapContext) r_m.getProduct();				ProductRef r_p = m.getRefs().get(productkey);				Product p = r_p.getProduct();				p.setCreator(creatorThree);				r_p = storageTwo.save(p);				m.getRefs().put(productkey, r_p);				storageTwo.save(m);				// _LOGGER.info(storageTwo.getVersioningInfo());			}			// Check the last version of the version tracks			{				// MapContext from pool 1				ProductRef r;				r = storageTwo.load(lastProductStorageOneUrn);				MapContext m_latest = (MapContext) (storageTwo.getHead(r))						.getProduct();				Product p = m_latest.getRefs().get(productkey).getProduct();				assertTrue(creatorThree.equals(p.getCreator()));				assertTrue(instrumentOne.equals(p.getInstrument()));			}			{				// MapContext from pool 2				ProductRef r;				r = storageTwo.load(storageTwoFirstProductUrn);				MapContext m_latest = (MapContext) (storageTwo.getHead(r))						.getProduct();				Product p = m_latest.getRefs().get(productkey).getProduct();				assertTrue(creatorTwo.equals(p.getCreator()));				assertTrue(instrumentTwo.equals(p.getInstrument()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// BASIC SAVE TESTS -------------------------------------------------------	/**	 * Create an instance of a leaf Product and save it twice. The second save	 * attempt should result in a new URN.	 */	public void testSaveNoModifyLeafProduct() {		saveNoModify(new Product(), true);	}	/**	 * Create an instance of a MapContext and save it twice. The second save	 * attempt should *not* result in a new URN, as the context has an isDirty()	 * method that indicates no in-memory updates.	 */	public void testSaveNoModifyMapContext() {		saveNoModify(new MapContext(), false);	}	/**	 * Create an instance of a ListContext and save it twice. The second save	 * attempt should *not* result in a new URN, as the context has an isDirty()	 * method that indicates no in-memory updates.	 */	public void testSaveNoModifyListContext() {		saveNoModify(new MapContext(), false);	}	/**	 * Save a leaf product, modify it and save it again. Both products should be	 * saved.	 */	public void testSaveAndModifyLeafProduct() {		saveAndModify(new Product(), true);	}	/**	 * Save a MapContext, modify it and save it again. Both products should be	 * saved.	 */	public void testSaveAndModifyMapContext() {		saveAndModify(new MapContext(), true);	}	/**	 * Save a ListContext, modify it and save it again. Both products should be	 * saved.	 */	public void testSaveAndModifyListContext() {		saveAndModify(new ListContext(), true);	}	/**	 * Save a leaf product, modify it and save it again. Both products should be	 * saved.	 */	public void testSaveAndModifyCleanlyLeafProduct() {		saveAndModifyCleanly(new Product(), true);	}	/**	 * Save a MapContext, modify it and save it again. Both products should be	 * saved.	 */	public void testSaveAndModifyCleanlyMapContext() {		saveAndModifyCleanly(new MapContext(), true);	}	/**	 * Save a ListContext, modify it and save it again. Both products should be	 * saved.	 */	public void testSaveAndModifyCleanlyListContext() {		saveAndModifyCleanly(new ListContext(), true);	}	/**	 * Create an instance of a leaf product and save it to one storage. Then	 * extract it and save it to a second empty storage. The second save should	 * result in a new urn corresponding to the second storage.	 * 	 */	public void testSaveAnotherStorageLeafProduct() {		saveAnotherStorage(new Product(), true);	}	/**	 * Create an instance of a MapContext and save it to one storage. Then	 * extract it and save it to a second empty storage. The second save should	 * result in a new urn corresponding to the second storage.	 * 	 */	public void testSaveAnotherStorageMapContext() {		saveAnotherStorage(new MapContext(), true);	}	/**	 * Create an instance of a ListContext and save it to one storage. Then	 * extract it and save it to a second empty storage. The second save should	 * result in a new urn corresponding to the second storage.	 * 	 */	public void testSaveAnotherStorageListContext() {		saveAnotherStorage(new ListContext(), true);	}	/**	 * Save a product to a storage, and save it once more to the same storage.	 */	private void saveNoModify(Product product, boolean urnChanged) {		final String creator1 = "creator 1";		try {			{				ProductPool pool = getPool(1);				ProductStorage storage = new ProductStorage();				storage.register(pool);				product.setCreator(creator1);				// Save				String urn1 = storage.save(product).getUrn();				// Save again				String urn2 = storage.save(product).getUrn();				if (urnChanged) {					assertFalse("URNs for the saved products (" + urn1 + ","							+ urn2 + ") should differ.", urn1.equals(urn2));				} else {					assertTrue("URNs for the saved products (" + urn1 + ","							+ urn2 + ") should be the same.", urn1.equals(urn2));				}			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * Save a product to a storage, modify it and save it once more to the same	 * storage.	 */	private void saveAndModify(Product product, boolean urnChanged) {		final String creator1 = "creator 1";		final String creator2 = "creator 2";		try {			{				ProductPool pool = getPool(1);				ProductStorage storage = new ProductStorage();				storage.register(pool);				product.setCreator(creator1);				String urn1 = storage.save(product).getUrn();				// Modify data				product.setCreator(creator2);				String urn2 = storage.save(product).getUrn();				if (urnChanged) {					assertFalse("URNs for the saved products (" + urn1 + ","							+ urn2 + ") should differ.", urn1.equals(urn2));				} else {					assertTrue("URNs for the saved products (" + urn1 + ","							+ urn2 + ") should be the same.", urn1.equals(urn2));				}			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * A variation of {@link #saveAndModify(Product, boolean)}: save a product,	 * but retrieve it from the store before modifying it a second time.	 */	private void saveAndModifyCleanly(Product product, boolean urnChanged) {		final String creator1 = "creator 1";		final String creator2 = "creator 2";		try {			ProductPool pool = getPool(1);			ProductStorage storage = new ProductStorage();			storage.register(pool);			String urn1;			String urn2;			{				product.setCreator(creator1);				urn1 = storage.save(product).getUrn();			}			{				// Modify data				ProductRef ref = storage.load(urn1);				Product pr = ref.getProduct();				// pr.setCreator(creator2);				pr.setDescription(creator2);				_LOGGER.info("second save");				urn2 = storage.save(pr).getUrn();				_LOGGER.info("second save done.");			}			{				if (urnChanged) {					assertFalse("URNs for the saved products (" + urn1 + ","							+ urn2 + ") should differ.", urn1.equals(urn2));				} else {					assertTrue("URNs for the saved products (" + urn1 + ","							+ urn2 + ") should be the same.", urn1.equals(urn2));				}			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * Save a product in one storage, access it and save it to another storage.	 */	private void saveAnotherStorage(Product product, boolean urnChanged) {		final String creator1 = "creator 1";		try {			{				ProductStorage storageA;				ProductStorage storageB;				String urn1;				String urn2;				{					ProductPool pool = getPool(1);					storageA = new ProductStorage();					storageA.register(pool);					product.setCreator(creator1);					// Save					urn1 = storageA.save(product).getUrn();				}				{					ProductPool pool = getPool(2);					storageB = new ProductStorage();					storageB.register(pool);					ProductRef ref = storageA.load(urn1);					// Save to second storage					urn2 = storageB.save(ref.getProduct()).getUrn();				}				{					if (urnChanged) {						assertFalse("URNs for the saved products (" + urn1								+ "," + urn2 + ") should differ.", urn1								.equals(urn2));					} else {						assertTrue("URNs for the saved products (" + urn1 + ","								+ urn2 + ") should be the same.", urn1								.equals(urn2));					}				}			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * 	 * This tests the tag name allowed format.	 * 	 */	public void testTagName() {		checkTagName("someTagWithoutSpaces", true);		checkTagName("some tag with spaces", true);		checkTagName("tag with\na new line", false);		checkTagName("urn:tagStartsWithUrn", false);	}	private void checkTagName(String tag, boolean isValid) {		try {			String messageNoValid = "IllegalArgumentException should be thrown";			String messageIsValid = "IllegalArgumentException shouldn't be thrown";			ProductStorage storage = new ProductStorage();			storage.register(getPool());			// save a product to create pool, compatible for SPR-4943			storage.save(new Product());			try {				assertFalse(storage.tagExists(tag));				if (!isValid)					fail(messageNoValid);			} catch (IllegalArgumentException e) {				if (isValid)					fail(messageIsValid);			}			try {				storage.saveAs(new Product(), tag);				if (!isValid)					fail(messageNoValid);			} catch (IllegalArgumentException e) {				if (isValid)					fail(messageIsValid);			}			try {				assertTrue(storage.tagExists(tag));				if (!isValid)					fail(messageNoValid);			} catch (IllegalArgumentException e) {				if (isValid)					fail(messageIsValid);			}			try {				storage.removeTag(tag);				if (!isValid)					fail(messageNoValid);			} catch (IllegalArgumentException e) {				if (isValid)					fail(messageIsValid);			}			try {				assertFalse(storage.tagExists(tag));				if (!isValid)					fail(messageNoValid);			} catch (IllegalArgumentException e) {				if (isValid)					fail(messageIsValid);			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * This tests the scenario where a user creates a product, and saves it to	 * the storage with an explicit tags Then further modifications and saves	 * are monitored.	 */	public void testAssignTag() {		final String tag = "myTag";		final String tagTwo = "mySecondTag";		final String wrongTagOne = "myWrongTag1\n";		final String wrongTagTwo = "urn:wrong:tag:2";		final String wrongUrn = "not:a:urn";		final String nonExistingUrn = "urn:not:existing:0";		final String descriptionOne = "Description 1";		final String descriptionTwo = "Description 2";		String urn;		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			try {				storage.setTag(tag, wrongUrn);				fail("An IllegalArgumentException should be raised");			} catch (IllegalArgumentException e) { /* correct */			}			try {				storage.setTag(tag, nonExistingUrn);				fail("A NoSuchElementException should be raised");			} catch (NoSuchElementException e) { /* correct */			}			{				// Create a product and save it under an explicit tag.				Product p = new TestProduct();				p.setDescription(descriptionOne);				urn = storage.saveAs(p, tag).getUrn();				assertEquals(storage.getAllTags().size(), 1);				assertEquals(storage.getTags(urn).size(), 1);				assertEquals(storage.getTags(urn).iterator().next(), tag);				assertEquals(storage.getUrnFromTag(tag), urn);				_LOGGER.info("Description = " + p.getDescription());			}			try {				storage.setTag(wrongTagOne, urn);				fail("An IllegalArgumentException should be raised");			} catch (IllegalArgumentException e) { /* correct */			}			try {				storage.setTag(wrongTagTwo, urn);				fail("An IllegalArgumentException should be raised");			} catch (IllegalArgumentException e) { /* correct */			}			{				// Load product using given tag				ProductRef r;				r = storage.load(tag);				Product p = r.getProduct();				_LOGGER.info("Description of reload product of tag \'" + tag						+ "\' = " + p.getDescription());				assertTrue(descriptionOne.equals(p.getDescription()));			}			{				// Modify and save it again, re-assigning the given tag.				// This should be added as the latest version of the product.				ProductRef r = storage.load(tag);				Product p = r.getProduct();				p.setDescription(descriptionTwo);				urn = storage.saveAs(p, tag).getUrn();				assertEquals(storage.getAllTags().size(), 1);				assertEquals(storage.getTags(urn).size(), 1);				assertEquals(storage.getTags(urn).iterator().next(), tag);				assertEquals(storage.getUrnFromTag(tag), urn);				// _LOGGER.info("Versioninginfo " +				// storage.getVersioningInfo());			}			{				// Load product using given tag				ProductRef r = storage.load(tag);				Product p = r.getProduct();				assertTrue(descriptionTwo.equals(p.getDescription()));			}			{				// Assign a second tag to the same product				urn = storage.load(tag).getUrn();				storage.setTag(tagTwo, urn);				assertEquals(storage.getAllTags().size(), 2);				assertEquals(storage.getTags(urn).size(), 2);				assertEquals(storage.getUrnFromTag(tag), urn);				assertEquals(storage.getUrnFromTag(tagTwo), urn);			}			{				// Load product using second tag				ProductRef r = storage.load(tagTwo);				assertTrue(urn.equals(r.getUrn()));				Product p = r.getProduct();				assertTrue(descriptionTwo.equals(p.getDescription()));				// _LOGGER.info("Versioninginfo " +				// storage.getVersioningInfo());			}			{				// Assign the tag to a new version				ProductRef r = storage.load(tag);				Product p = r.getProduct();				p.setDescription(descriptionTwo);				urn = storage.saveAs(p, tag).getUrn();				assertEquals(storage.getAllTags().size(), 2);				assertEquals(storage.getTags(urn).size(), 1);				assertEquals(storage.getUrnFromTag(tag), urn);				storage.removeTag(tag);				assertEquals(storage.getTags(urn).size(), 0);			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * This tests that tags can be assigned, and removed correctly.	 */	public void testRemoveTag() {		final String tagOne = "tagOne";		final String tagTwo = "tagTwo";		final String descriptionOne = "Description 1";		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			// Test that a null tag or a tag that is not present throws			// NoSuchElementException			// save a product to create pool, compatible for SPR-4943			storage.save(new Product());			try {				storage.removeTag(tagTwo);				fail("This test should have raised a NoSuchElementException");			} catch (NoSuchElementException e) { /* test succeeded */			}			try {				storage.load(tagTwo);				fail("This test should have raised a NoSuchElementException");			} catch (NoSuchElementException e) { /* test succeeded */			}			try {				storage.load(null);				fail("This test should have raised an IllegalArgumentException");			} catch (IllegalArgumentException e) { /* test succeeded */			}			// Test the tagExists method throws an exception if the argument is			// null			try {				storage.tagExists(null);				fail("This test should have raised an IllegalArgumentException");			} catch (IllegalArgumentException e) { /* test succeeded */			}			{				// Create a product and save it under an explicit tag.				Product p = new TestProduct();				p.setDescription(descriptionOne);				storage.saveAs(p, tagOne);			}			{				// Load product using given tag				ProductRef r;				r = storage.load(tagOne);				Product p = r.getProduct();				_LOGGER						.info("Description of reload product of version track \'"								+ tagOne + "\' = " + p.getDescription());				assertTrue(descriptionOne.equals(p.getDescription()));			}			{				storage.removeTag(tagOne);				try {					storage.load(tagOne);					fail("This test should have raised a NoSuchElementException");				} catch (NoSuchElementException e) { /* test succeeded */				}			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// CLONING OF VERSIONS ---------------------------------------------------	/**	 * Generate a map context in one storage. Add two leaf products one at a	 * time, with saves in between, such that two versions of the context are	 * saved, with the initial version having only one leaf product. Then clone	 * the context. The two versions of context, with the initial version having	 * only one leaf product, should be cloned to the destination.	 */	public void testDeepCloningMapContext() {		final String productOneKey = "leafproduct 1";		final String descriptionOne = "description 1";		final String productTwoKey = "leafproduct 2";		final String descriptionTwo = "description 2";		try {			ProductRef context_ref;			// String productDesc;			// Populate first storage			{				ProductPool pool = getPool(1);				ProductStorage storage = new ProductStorage();				storage.register(pool);				// Create two products and save them to the storage				ProductRef rOne;				ProductRef rTwo;				{					Product p = new TestProduct();					p.setDescription(descriptionOne);					rOne = storage.save(p);				}				{					Product p = new TestProduct();					p.setDescription(descriptionTwo);					rTwo = storage.save(p);				}				// Create a context				MapContext mapContext = new MapContext();				// Set type (as this is needed by the versioning mechanism)				mapContext.setType(_MAPCONTEXT_TYPE);				// Now add the first product and save => first version of this				// context)				mapContext.getRefs().put(productOneKey, rOne);				storage.save(mapContext);				// Now add the second product and save => second version of this				// context)				mapContext.getRefs().put(productTwoKey, rTwo);				context_ref = storage.save(mapContext);				int numberOfVersions = storage.getVersions(context_ref).size();				assertTrue("Expected 2 versions of context. Got "						+ numberOfVersions, numberOfVersions == 2);			}			/*			 * Following checks expect the versions to be cloned, which is not			 * the case,			 * 			 * because ProductStorage.save doesn't clone previous versions any			 * more.			 *  { // Now try to clone data to second pool ProductPool pool =			 * getPool(2);			 * 			 * ProductStorage storage = new ProductStorage();			 * storage.register(pool);			 * 			 * ProductRef ref = storage.save(context_ref.getProduct());			 * 			 * int numberOfVersions = storage.getVersions(ref).size();			 * assertTrue("Expected 2 versions of context. Got " +			 * numberOfVersions, numberOfVersions == 2);			 * 			 * List<ProductRef> versions = storage.getVersions(ref); { { Set<ProductRef>			 * refs = ((MapContext) versions .get(0).getProduct()).getAllRefs();			 * assertTrue("Expected one child of context. Got " + refs.size(),			 * refs.size() == 1); for (ProductRef r : refs) { productDesc =			 * r.getProduct().getDescription();			 * assertTrue(descriptionOne.equals(productDesc)); } } { Set<ProductRef>			 * refs = ((MapContext) versions .get(1).getProduct()).getAllRefs();			 * assertTrue("Expected two children of context. Got " +			 * refs.size(), refs.size() == 2); int match = 0; for (ProductRef r :			 * refs) { productDesc = r.getProduct().getDescription(); if			 * (descriptionOne.equals(productDesc) ||			 * descriptionTwo.equals(productDesc)) { ++match; } }			 * assertTrue(match == 2); } } }			 */		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * Generate a list context in one storage. Add two leaf products one at a	 * time, with saves in between, such that two versions of the context are	 * saved, with the initial version having only one leaf product. Then clone	 * the context. The two versions of context, with the initial version having	 * only one leaf product, should be cloned to the destination.	 */	public void testDeepCloningListContext() {		final String descriptionOne = "description 1";		final String descriptionTwo = "description 2";		try {			ProductRef context_ref;			// String productDesc;			// Populate first storage			{				ProductPool pool = getPool(1);				ProductStorage storage = new ProductStorage();				storage.register(pool);				// Create two products and save them to the storage				ProductRef rOne;				ProductRef rTwo;				{					Product p = new TestProduct();					p.setDescription(descriptionOne);					rOne = storage.save(p);				}				{					Product p = new TestProduct();					p.setDescription(descriptionTwo);					rTwo = storage.save(p);				}				// Create a context				ListContext listContext = new ListContext();				// Set type (as this is needed by the versioning mechanism)				listContext.setType(_LISTCONTEXT_TYPE);				// Now add the first product and save => first version of this				// context)				listContext.getRefs().add(rOne);				storage.save(listContext);				// Now add the second product and save => second version of this				// context)				listContext.getRefs().add(rTwo);				context_ref = storage.save(listContext);				int numberOfVersions = storage.getVersions(context_ref).size();				assertTrue("Expected 2 versions of context. Got "						+ numberOfVersions, numberOfVersions == 2);			}			/*			 * Following checks expect the versions to be cloned, which is not			 * the case,			 * 			 * because ProductStorage.save doesn't clone previous versions any			 * more.			 *  { // Now try to clone data to second pool ProductPool pool =			 * getPool(2);			 * 			 * ProductStorage storage = new ProductStorage();			 * storage.register(pool);			 * 			 * ProductRef ref = storage.save(context_ref.getProduct());			 * 			 * int numberOfVersions = storage.getVersions(ref).size();			 * assertTrue("Expected 2 versions of context. Got " +			 * numberOfVersions, numberOfVersions == 2);			 * 			 * List<ProductRef> versions = storage.getVersions(ref); { { Set<ProductRef>			 * refs = ((ListContext) versions.get(			 * 0).getProduct()).getAllRefs(); assertTrue("Expected one child of			 * context. Got " + refs.size(), refs.size() == 1); for (ProductRef			 * r : refs) { productDesc = r.getProduct().getDescription();			 * assertTrue(descriptionOne.equals(productDesc)); } } { Set<ProductRef>			 * refs = ((ListContext) versions.get(			 * 1).getProduct()).getAllRefs(); assertTrue("Expected two children			 * of context. Got " + refs.size(), refs.size() == 2); int match =			 * 0; for (ProductRef r : refs) { productDesc =			 * r.getProduct().getDescription(); if			 * (descriptionOne.equals(productDesc) ||			 * descriptionTwo.equals(productDesc)) { ++match; } }			 * assertTrue(match == 2); } } }			 */		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * More complex test. Generate a map context in one storage. Add two list	 * contexts as children (with the first list context in turn having a child	 * leaf context) to the map context one at a time, with saves in between,	 * such that two versions of the context are saved, with the initial version	 * having only one list context instance. Then clone the context. The two	 * versions of context, with the initial version having only one list	 * context - with a leaf context as child, should be cloned to the	 * destination.	 */	public void testDeepCloningMapListContext() {		final String productOneKey = "child listcontext 1";		final String descriptionListContextOne = "description 1";		final String descriptionLeaf = "description leaf";		final String productTwoKey = "child listcontext 2";		final String descriptionListContextTwo = "description 2";		try {			ProductRef context_ref;			// String productDesc;			// Populate first storage			{				ProductPool pool = getPool(1);				ProductStorage storage = new ProductStorage();				storage.register(pool);				// Create two products and save them to the storage				ProductRef rOne;				ProductRef rTwo;				{					ListContext lcontext = new ListContext();					lcontext.setType(_LISTCONTEXT_TYPE);					lcontext.setDescription(descriptionListContextOne);					Product p = new TestProduct();					p.setDescription(descriptionLeaf);					ProductRef p_ref = storage.save(p);					p.setDescription(descriptionListContextOne);					lcontext.getRefs().add(p_ref);					rOne = storage.save(lcontext);				}				{					Product lcontext = new ListContext();					lcontext.setType(_LISTCONTEXT_TYPE);					lcontext.setDescription(descriptionListContextTwo);					rTwo = storage.save(lcontext);				}				// Create a context				MapContext mapContext = new MapContext();				// Set type (as this is needed by the versioning mechanism)				mapContext.setType(_MAPCONTEXT_TYPE);				// Now add the first product and save => first version of this				// context)				mapContext.getRefs().put(productOneKey, rOne);				storage.save(mapContext);				// Now add the second product and save => second version of this				// context)				mapContext.getRefs().put(productTwoKey, rTwo);				context_ref = storage.save(mapContext);				int numberOfVersions = storage.getVersions(context_ref).size();				assertTrue("Expected 2 versions of context. Got "						+ numberOfVersions, numberOfVersions == 2);			}			/*			 * Following checks expect the versions to be cloned, which is not			 * the case,			 * 			 * because ProductStorage.save doesn't clone previous versions any			 * more. { // Now try to clone data to second pool ProductPool pool =			 * getPool(2);			 * 			 * ProductStorage storage = new ProductStorage();			 * storage.register(pool);			 * 			 * ProductRef ref = storage.save(context_ref.getProduct());			 * 			 * //_LOGGER.info("versions in storage " +			 * storage.getVersioningInfo());			 * 			 * _LOGGER.info("Result="+((MapContext)			 * ref.getProduct()).getAllRefs());			 * 			 * int numberOfVersions = storage.getVersions(ref).size();			 * assertTrue("Expected 2 versions of context. Got " +			 * numberOfVersions, numberOfVersions == 2);			 * 			 * List<ProductRef> versions = storage.getVersions(ref); { {			 * ProductRef ref_0 = versions.get(0); _LOGGER.info("Version 0 " +			 * ref_0); Set<ProductRef> refs = ((MapContext) versions			 * .get(0).getProduct()).getAllRefs();			 * 			 * _LOGGER.info("child refs=" + refs);			 * 			 * assertTrue("Expected one child of context. Got " + refs.size(),			 * refs.size() == 1); for (ProductRef r : refs) { ListContext			 * lcontext = (ListContext) r .getProduct();			 * assertTrue(descriptionListContextOne			 * .equals(lcontext.getDescription())); List<ProductRef>			 * childrenOfListContext = lcontext .getRefs(); int			 * numberOfChildrenOfListContext = childrenOfListContext.size();			 * assertTrue( "Expected 1 child of list context. Got " +			 * numberOfChildrenOfListContext, numberOfChildrenOfListContext ==			 * 1); assertTrue(descriptionLeaf			 * .equals(childrenOfListContext.get(0)			 * .getProduct().getDescription())); } } { Set<ProductRef> refs =			 * ((MapContext) versions .get(1).getProduct()).getAllRefs();			 * assertTrue("Expected two children of context. Got " +			 * refs.size(), refs.size() == 2);			 * 			 * int match = 0; for (ProductRef r : refs) { productDesc =			 * r.getProduct().getDescription(); if			 * (descriptionListContextOne.equals(productDesc) ||			 * descriptionListContextTwo.equals(productDesc)) { ++match; } }			 * assertTrue(match == 2); } } }			 *  { // Further test. Clone data to second storage that contains //			 * the original pool. No cloning operation should occur. ProductPool			 * poolA = getPool(1); ProductPool poolB = getPool(2);			 * 			 * ProductStorage storage = new ProductStorage();			 * storage.register(poolA); storage.register(poolB);			 * 			 * ProductRef ref = storage.save(context_ref.getProduct());			 * 			 * //_LOGGER.info(storage.getVersioningInfo());			 * 			 * int numberOfVersions = storage.getVersions(ref).size();			 * assertTrue("Expected 2 versions of context. Got " +			 * numberOfVersions, numberOfVersions == 2);			 * 			 * List<ProductRef> versions = storage.getVersions(ref); { { Set<ProductRef>			 * refs = ((MapContext) versions .get(0).getProduct()).getAllRefs();			 * assertTrue("Expected one child of context. Got " + refs.size(),			 * refs.size() == 1); for (ProductRef r : refs) { ListContext			 * lcontext = (ListContext) r .getProduct();			 * assertTrue(descriptionListContextOne			 * .equals(lcontext.getDescription())); List<ProductRef>			 * childrenOfListContext = lcontext .getRefs(); int			 * numberOfChildrenOfListContext = childrenOfListContext.size();			 * assertTrue( "Expected 1 child of list context. Got " +			 * numberOfChildrenOfListContext, numberOfChildrenOfListContext ==			 * 1); assertTrue(descriptionLeaf			 * .equals(childrenOfListContext.get(0)			 * .getProduct().getDescription())); } } { Set<ProductRef> refs =			 * ((MapContext) versions .get(1).getProduct()).getAllRefs();			 * assertTrue("Expected two children of context. Got " +			 * refs.size(), refs.size() == 2);			 * 			 * int match = 0; for (ProductRef r : refs) { productDesc =			 * r.getProduct().getDescription(); if			 * (descriptionListContextOne.equals(productDesc) ||			 * descriptionListContextTwo.equals(productDesc)) { ++match; } }			 * assertTrue(match == 2); } } }			 */		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// CLONING SCATTERED CONTEXT ----------------------------------------------	/**	 * Generate a ListContext in poolA, with a child leaf product in poolB.	 * Clone to a new storage which contains just poolA, such that child needs	 * to be copied to poolA.	 */	public void testCloningScatteredListChildLeaf() {		cloningScatteredListContext(new TestProduct());	}	/**	 * Generate a ListContext in poolA, with a child list context in poolB.	 * Clone to a new storage which contains just poolA, such that child needs	 * to be copied to poolA.	 */	public void testCloningScatteredListChildListContext() {		cloningScatteredListContext(new ListContext());	}	/**	 * Generate a MapContext in poolA, with a child leaf product in poolB. Clone	 * to a new storage which contains just poolA, such that child needs to be	 * copied to poolA.	 */	public void testCloningScatteredMapChildLeaf() {		cloningScatteredMapContext(new TestProduct());	}	/**	 * Generate a MapContext in poolA, with a child list context in poolB. Clone	 * to a new storage which contains just poolA, such that child needs to be	 * copied to poolA.	 */	public void testCloningScatteredMapChildListContext() {		cloningScatteredMapContext(new ListContext());	}	private void cloningScatteredListContext(Product child) {		final String creator = "creator";		ProductPool poolA = getPool(1);		ProductPool poolB = getPool(2);		try {			// Add leaf product to poolB			ProductRef child_ref;			{				ProductStorage storage = new ProductStorage();				storage.register(poolB);				child.setCreator(creator);				child_ref = storage.save(child);				_LOGGER.info("child_ref urn=" + child_ref.getUrn());			}			// Add context to pool A, referencing child in pool B			String context_urn;			{				ProductStorage storage = new ProductStorage();				storage.register(poolA);				storage.register(poolB);				ListContext listcontext = new ListContext();				listcontext.getRefs().add(child_ref);				_LOGGER.info("storage of child ref:"						+ listcontext.getRefs().get(0).getStorage());				ProductRef ref = storage.save(listcontext);				context_urn = ref.getUrn();			}			// Clone context to pool A			String context_modified_urn;			{				ListContext listcontext;				{					ProductStorage storage = new ProductStorage();					storage.register(poolA);					storage.register(poolB);					ProductRef ref = storage.load(context_urn);					listcontext = (ListContext) ref.getProduct();				}				{					ProductStorage storage = new ProductStorage();					storage.register(poolA);					context_modified_urn = storage.save(listcontext).getUrn();				}			}			// Validate changes			{				assertFalse("Context urns" + context_urn + "  and "						+ context_modified_urn + " should differ.", context_urn						.equals(context_modified_urn));				ProductStorage storage = new ProductStorage();				storage.register(poolA);				ProductRef ref = storage.load(context_modified_urn);				ListContext listcontext = (ListContext) ref.getProduct();				String child_modified_urn = listcontext.getRefs().get(0)						.getUrn();				String child_urn = child_ref.getUrn();				assertFalse("Child urns " + child_urn + "  and "						+ child_modified_urn + " should differ.",						child_modified_urn.equals(child_urn));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	private void cloningScatteredMapContext(Product child) {		final String childKey = "child";		final String creator = "creator";		ProductPool poolA = getPool(1);		ProductPool poolB = getPool(2);		try {			// Add leaf product to poolB			ProductRef childRef;			{				ProductStorage storage = new ProductStorage();				storage.register(poolB);				child.setCreator(creator);				childRef = storage.save(child);				_LOGGER.info("childRef urn=" + childRef.getUrn());			}			// Add context to pool A, referencing child in pool B			String contextUrn;			{				ProductStorage storage = new ProductStorage();				storage.register(poolA);				storage.register(poolB);				MapContext mc = new MapContext();				mc.getRefs().put(childKey, childRef);				_LOGGER.info("storage of child ref:"						+ mc.getRefs().get(childKey).getStorage());				ProductRef ref = storage.save(mc);				contextUrn = ref.getUrn();			}			// Clone context to pool A			String contextModifiedUrn;			{				MapContext mc;				{					ProductStorage storage = new ProductStorage();					storage.register(poolA);					storage.register(poolB);					ProductRef ref = storage.load(contextUrn);					mc = (MapContext) ref.getProduct();				}				{					ProductStorage storage = new ProductStorage();					storage.register(poolA);					contextModifiedUrn = storage.save(mc).getUrn();				}			}			// Validate changes			{				assertFalse("Context urns " + contextUrn + " and " +				contextModifiedUrn + " should differ.",				contextModifiedUrn.equals(contextUrn));				ProductStorage storage = new ProductStorage();				storage.register(poolA);				ProductRef ref = storage.load(contextModifiedUrn);				MapContext mc = (MapContext) ref.getProduct();				String childModifiedUrn = mc.getRefs().get(childKey).getUrn();				String childUrn = childRef.getUrn();				assertFalse("Child urns " + childUrn + " and "						+ childModifiedUrn + " should differ.",						childModifiedUrn.equals(childUrn));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// FIND TAGS PRODUCT ------------------------------------------------	/**	 * 	 * Tests that tags product can be located.	 * 	 */	public void testFindTagsProducts() {		try {			ProductStorage storage = new ProductStorage();			storage.register(getPool());			// Create a product and save it			Product p = new TestProduct();			String urn = storage.save(p).getUrn();			// Associate tags to the product			storage.setTag("tag1", urn);			storage.saveAs(p, "tag2");			// Now, try to find TagsProduct			AttribQuery query = new AttribQuery(TagsProduct.class, "p", "1",					true);			Set<ProductRef> result = storage.select(query);			assertEquals(2, result.size()); // two because TagsProduct is											// versioned		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// // FIND VERSIONING PRODUCT	// ------------------------------------------------	//	// /**	// * Tests that versioning product can be located.	// */	// public void testFindVersioningProduct() {	//	// final String descriptionOne = "Description 1";	// final String descriptionTwo = "Description 2";	//	// try {	//	// ProductStorage storage = new ProductStorage();	// storage.register(getPool(1));	//	// {	// String urn;	// {	// // Create a product and save it under an implicit version	// // track.	// Product p = new TestProduct();	// p.setDescription(descriptionOne);	// urn = storage.save(p).getUrn();	// }	//	// {	// // Re-load product using urn	// ProductRef r = storage.load(urn);	// Product p = r.getProduct();	// assertTrue(descriptionOne.equals(p.getDescription()));	// }	//	// {	// // Modify and save it again	// // This should be added as the latest version of the	// // product.	// ProductRef r = storage.load(urn);	// Product p = r.getProduct();	// p.setDescription(descriptionTwo);	// storage.save(p);	// }	// }	//	// {	// // Now, try to find VersionProduct in system	// AttribQuery query = new AttribQuery(_VERSION_PRODUCT_CLASS,	// "p", "1", true);	// _LOGGER.info("Looking for VersionProduct in storage..");	// Set<ProductRef> resultset = storage.select(query);	// _LOGGER.info("Found " + resultset.size() + " VersionProducts in	// storage.");	// }	//	// } catch (IOException e) {	// fail("Following exception was raised " + StackTrace.trace(e));	// } catch (GeneralSecurityException e) {	// fail("Following exception was raised " + StackTrace.trace(e));	// }	// }	//	// public void testFindVersioningProductTwo() {	//	// final String descriptionOne = "Description 1";	// final String descriptionTwo = "Description 2";	//	// try {	//	// {	// ProductStorage storage = new ProductStorage();	// storage.register(getPool(1));	//	// String urn;	// {	// // Create a product and save it under an implicit version	// // track.	// Product p = new TestProduct();	// p.setDescription(descriptionOne);	// urn = storage.save(p).getUrn();	// }	//	// {	// // Re-load product using urn	// ProductRef r = storage.load(urn);	// Product p = r.getProduct();	// assertTrue(descriptionOne.equals(p.getDescription()));	// }	//	// {	// // Modify and save it again	// // This should be added as the latest version of the	// // product.	// ProductRef r = storage.load(urn);	// Product p = r.getProduct();	// p.setDescription(descriptionTwo);	// storage.save(p);	// }	// }	//	// {	// ProductStorage storage = new ProductStorage();	// storage.register(getPool(2));	//	// String urn;	// {	// // Create a product and save it under an implicit version	// // track.	// Product p = new TestProduct();	// p.setDescription(descriptionOne);	// urn = storage.save(p).getUrn();	// }	//	// {	// // Re-load product using urn	// ProductRef r = storage.load(urn);	// Product p = r.getProduct();	// assertTrue(descriptionOne.equals(p.getDescription()));	// }	//	// {	// // Modify and save it again	// // This should be added as the latest version of the	// // product.	// ProductRef r = storage.load(urn);	// Product p = r.getProduct();	// p.setDescription(descriptionTwo);	// storage.save(p);	// }	// }	//	// {	// ProductStorage storage = new ProductStorage();	// storage.register(getPool(1));	// storage.register(getPool(2));	//	// // Now, try to find VersionProduct in system	// // Now, try to find VersionProduct in system	// AttribQuery query = new AttribQuery(_VERSION_PRODUCT_CLASS,	// "p", "1", true);	// _LOGGER.info("Looking for VersionProduct in storage..");	// Set<ProductRef> resultset = storage.select(query);	// _LOGGER.info("Found " + resultset.size() + " VersionProducts in	// storage.");	// }	//	// } catch (IOException e) {	// fail("Following exception was raised " + StackTrace.trace(e));	// } catch (GeneralSecurityException e) {	// fail("Following exception was raised " + StackTrace.trace(e));	// }	// }	// MERGED VERSION ---------------------------------------------------------	/**	 * In this test there are initially two pools. A product is written to the	 * two pools individually, such that the two products possess the same	 * version track ID. New versions of the product in the second pool are	 * generated. The data in the two pools are then accessed from a single	 * ProductStorage. The result should be that the versions of product in the	 * first pool is the only one listed. Further tests are run using 3 pools.	 */	public void testSimpleVersionMerging() {		final String creatorOne = "Creator1";		final String creatorTwo = "Creator2";		final String creatorThree = "Creator3";		String urnToProductA;		String urnToProductB0;		String urnToProductB1;		String urnToProductB2;		try {			ProductPool poolA = getPool(1);			ProductPool poolB = getPool(2);			{				Product p = new Product();				p.setCreator(creatorOne);				ProductStorage storage = new ProductStorage();				storage.register(poolA);				ProductRef ref = storage.save(p);				urnToProductA = ref.getUrn();				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected one version in list. Got " + refs.size(),						refs.size() == 1);				assertTrue("Expected urn " + urnToProductA + " . Got "						+ refs.get(0).getUrn(), refs.get(0).getUrn().equals(						urnToProductA));			}			{				Product p = new Product();				p.setCreator(creatorOne);				ProductStorage storage = new ProductStorage();				storage.register(poolB);				ProductRef ref = storage.save(p);				urnToProductB0 = ref.getUrn();				// Modify product				p.setCreator(creatorTwo);				urnToProductB1 = storage.save(p).getUrn();				// Modify product again				p.setCreator(creatorThree);				urnToProductB2 = storage.save(p).getUrn();				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected 3 versions in list. Got " + refs.size(),						refs.size() == 3);				assertTrue("Expected version to have urn " + urnToProductB0						+ " . Got " + refs.get(0).getUrn(), refs.get(0)						.getUrn().equals(urnToProductB0));				assertTrue("Expected version to have urn " + urnToProductB1						+ " . Got " + refs.get(1).getUrn(), refs.get(1)						.getUrn().equals(urnToProductB1));				assertTrue("Expected version to have urn " + urnToProductB2						+ " . Got " + refs.get(2).getUrn(), refs.get(2)						.getUrn().equals(urnToProductB2));			}			{				// Now access the two pools in a single storage				ProductStorage storage = new ProductStorage();				storage.register(poolA);				storage.register(poolB);				_LOGGER.info("loading product " + urnToProductA);				ProductRef ref = storage.load(urnToProductA);				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected one version in list. Got " + refs.size(),						refs.size() == 1);				assertTrue("Expected urn " + urnToProductA + " . Got "						+ refs.get(0).getUrn(), refs.get(0).getUrn().equals(						urnToProductA));			}			{				// Swap the two pools around. Should now see 3 versions in the				// first pool				ProductStorage storage = new ProductStorage();				storage.register(poolB);				storage.register(poolA);				ProductRef ref = storage.load(urnToProductB0);				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected 3 versions in list. Got " + refs.size(),						refs.size() == 3);				assertTrue("Expected version to have urn " + urnToProductB0						+ " . Got " + refs.get(0).getUrn(), refs.get(0)						.getUrn().equals(urnToProductB0));				assertTrue("Expected version to have urn " + urnToProductB1						+ " . Got " + refs.get(1).getUrn(), refs.get(1)						.getUrn().equals(urnToProductB1));				assertTrue("Expected version to have urn " + urnToProductB2						+ " . Got " + refs.get(2).getUrn(), refs.get(2)						.getUrn().equals(urnToProductB2));			}			// See if a third pool causes problems			ProductPool poolC = getPool(3);			String urnToProductC;			{				Product p = new Product();				p.setCreator(creatorOne);				ProductStorage storage = new ProductStorage();				storage.register(poolC);				urnToProductC = storage.save(p).getUrn();			}			{				ProductStorage storage = new ProductStorage();				storage.register(poolC);				storage.register(poolA);				storage.register(poolB);				_LOGGER.info("loading product " + urnToProductC);				ProductRef ref = storage.load(urnToProductC);				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected one version in list. Got " + refs.size(),						refs.size() == 1);				assertTrue("Expected urn " + urnToProductC + " . Got "						+ refs.get(0).getUrn(), refs.get(0).getUrn().equals(						urnToProductC));			}			{				ProductStorage storage = new ProductStorage();				storage.register(poolA);				storage.register(poolC);				storage.register(poolB);				_LOGGER.info("loading product " + urnToProductA);				ProductRef ref = storage.load(urnToProductA);				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected one version in list. Got " + refs.size(),						refs.size() == 1);				assertTrue("Expected urn " + urnToProductA + " . Got "						+ refs.get(0).getUrn(), refs.get(0).getUrn().equals(						urnToProductA));			}			{				ProductStorage storage = new ProductStorage();				storage.register(poolB);				storage.register(poolC);				storage.register(poolA);				ProductRef ref = storage.load(urnToProductB0);				List<ProductRef> refs = storage.getVersions(ref);				assertTrue("Expected 3 versions in list. Got " + refs.size(),						refs.size() == 3);				assertTrue("Expected version to have urn " + urnToProductB0						+ " . Got " + refs.get(0).getUrn(), refs.get(0)						.getUrn().equals(urnToProductB0));				assertTrue("Expected version to have urn " + urnToProductB1						+ " . Got " + refs.get(1).getUrn(), refs.get(1)						.getUrn().equals(urnToProductB1));				assertTrue("Expected version to have urn " + urnToProductB2						+ " . Got " + refs.get(2).getUrn(), refs.get(2)						.getUrn().equals(urnToProductB2));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * In this test there are two pools. A product is written to the two pools	 * individually, such that the two products possess the same tag. The data	 * in the two pools are then accessed from a single ProductStorage. The	 * result should be that the versions of product in the first pool is the	 * only one listed.	 * 	 */	public void testSimpleTagMerging() {		final String tag = "myTag";		final String creatorOne = "Creator1";		final String creatorTwo = "Creator2";		try {			ProductPool poolA = getPool(1);			ProductPool poolB = getPool(2);			String urnA;			String urnB;			{				Product p = new Product();				p.setCreator(creatorOne);				ProductStorage storage = new ProductStorage();				storage.register(poolA);				urnA = storage.saveAs(p, tag).getUrn();				ProductRef r = storage.load(tag);				assertTrue("urn" + r.getUrn() + " differs from that expected: "						+ urnA, urnA.equals(r.getUrn()));			}			{				Product p = new Product();				p.setCreator(creatorTwo);				ProductStorage storage = new ProductStorage();				storage.register(poolB);				urnB = storage.saveAs(p, tag).getUrn();				ProductRef r = storage.load(tag);				assertTrue("urn" + r.getUrn() + " differs from that expected: "						+ urnB, urnB.equals(r.getUrn()));			}			{				// Now access the two pools in a single storage				ProductStorage storage = new ProductStorage();				storage.register(poolA);				storage.register(poolB);				ProductRef r = storage.load(tag);				assertTrue("urn" + r.getUrn() + " differs from that expected: "						+ urnA, urnA.equals(r.getUrn()));			}			{				// Swap the two pools around. Should now see 3 versions in the				// first pool				ProductStorage storage = new ProductStorage();				storage.register(poolB);				storage.register(poolA);				ProductRef r = storage.load(tag);				assertTrue("urn" + r.getUrn() + " differs from that expected: "						+ urnB, urnB.equals(r.getUrn()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// // PRODUCT REF WITH TAG	// ---------------------------------------------------	//	// THE CONSTRUCTOR TESTED HERE IS DEPRECATED: TEST REMOVED	// /**	// * This test asserts that an {@link IllegalArgumentException} is raised if	// * a tag is attempted to be assigned instead of a URN during	// * {@link ProductRef} construction.	// */	// public void testRefWithTag() {	//	// final String tag = "mytag";	//	// ProductStorage storage = new ProductStorage();	// storage.register(getPool());	//	// try {	// // Create special product ref with a tag, not an absolute urn	// new ProductRef(storage, tag);	// fail("The productref should not have been constructed with the tag "	// + tag);	// } catch (IOException e) {	// fail("Following exception was raised " + StackTrace.trace(e));	// } catch (GeneralSecurityException e) {	// fail("Following exception was raised " + StackTrace.trace(e));	// }	// catch (IllegalArgumentException e){	// // Test succeeded.	// }	// }	// QUERY VERSIONING -------------------------------------------------------	/**	 * Checks that products of the specified class and subclasses are returned.	 */	public void testProductSubclasses() {		try {			ProductPool pool = getPool();			ProductStorage storage = new ProductStorage();			storage.register(pool);			Product p = new Product();			ListContext lc = new ListContext();			MapContext mc = new MapContext();			String urnP = storage.save(p).getUrn();			String urnLc = storage.save(lc).getUrn();			String urnMc = storage.save(mc).getUrn();			StorageQuery query;			Set<String> urns;			Set<ProductRef> refs;			query = new FullQuery(Product.class, "p", "1");			refs = storage.select(query);			urns = getUrns(refs);			_LOGGER.info("urns" + urns);			assertTrue(urns.size() == 3);			assertTrue(urns.contains(urnP));			assertTrue(urns.contains(urnLc));			assertTrue(urns.contains(urnMc));			query = new AttribQuery(Context.class, "p", "1");			refs = storage.select(query);			urns = getUrns(refs);			_LOGGER.info("urns" + urns);			assertEquals(urns.size(), 2);			assertFalse(urns.contains(urnP));			assertTrue(urns.contains(urnLc));			assertTrue(urns.contains(urnMc));			query = new MetaQuery(MapContext.class, "p", "1");			refs = storage.select(query);			urns = getUrns(refs);			_LOGGER.info("urns" + urns);			assertEquals(urns.size(), 1);			assertFalse(urns.contains(urnP));			assertFalse(urns.contains(urnLc));			assertTrue(urns.contains(urnMc));		} catch (IOException e) {			fail("Unexpected IOException found. Details:" + e);		} catch (GeneralSecurityException e) {			fail("Unexpected GeneralSecurityException found. Details:" + e);		}	}	private Set<String> getUrns(Set<ProductRef> refs) {		Set<String> urns = new HashSet<String>();		for (ProductRef ref : refs) {			urns.add(ref.getUrn());		}		return urns;	}	/**	 * This tests the scenario where a user saves two versions of a single	 * product instance. The query should return just the latest version.	 * 	 */	public void testSingleProductQuery() {		final String creatorOne = "Creator1";		final String creatorTwo = "Creator2";		final String instrumentOne = "InstrumentOne";		final String instrumentTwo = "InstrumentTwo";		AttribQuery queryLatestVersions, queryAllVersions;		queryLatestVersions = new AttribQuery(TestProduct.class, "p", "1");		queryAllVersions = new AttribQuery(TestProduct.class, "p", "1", true);		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			String urn;			{				// Create a product and save it.				Product p = new TestProduct();				p.setCreator(creatorOne);				p.setInstrument(instrumentOne);				urn = storage.save(p).getUrn();				// _LOGGER.info(storage.getVersioningInfo());			}			{				// Load product using given alias				ProductRef r = storage.load(urn);				Product p = r.getProduct();				assertTrue(creatorOne.equals(p.getCreator()));			}			{				// Modify and save it again.				// This should be added as the latest version of the product.				ProductRef r = storage.load(urn);				Product p = r.getProduct();				p.setCreator(creatorTwo);				// _LOGGER.info(storage.getVersioningInfo());				storage.save(p);				// _LOGGER.info(storage.getVersioningInfo());			}			{				// Run the select in default mode: latest version only produced				{					Set<ProductRef> result = storage							.select(queryLatestVersions);					assertTrue(result.size() == 1);					// Check that it is the latest version					Iterator<ProductRef> it = result.iterator();					ProductRef r = it.next();					_LOGGER.info("ref=" + r);					Product p = r.getProduct();					_LOGGER.info("p.creator=" + p.getCreator());					assertTrue(creatorTwo.equals(p.getCreator()));				}				// Run the select in advanced mode: versions of all products are				// given.				{					Set<ProductRef> resultset = storage							.select(queryAllVersions);					// _LOGGER.info(storage.getVersioningInfo());					for (ProductRef r : resultset) {						_LOGGER.info(r.getUrn());					}					assertTrue("Expected two elements in result. Got "							+ resultset.size(), resultset.size() == 2);					Iterator<ProductRef> it = resultset.iterator();					boolean creatorOneFound = false;					boolean creatorTwoFound = false;					while (it.hasNext()) {						ProductRef r = it.next();						Product p = r.getProduct();						String creator = p.getCreator();						if (creatorOne.equals(creator)) {							creatorOneFound = true;						}						if (creatorTwo.equals(creator)) {							creatorTwoFound = true;						}					}					assertTrue(creatorOneFound && creatorTwoFound);				}				// Now add another product of the same type to the storage.				// This will be saved on a different version track,				// and should appear as a result in the query providing latest				// versions.				{					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentTwo);					storage.save(p);				}				{					Set<ProductRef> resultset = storage							.select(queryLatestVersions);					assertTrue(resultset.size() == 2);					Iterator<ProductRef> it = resultset.iterator();					boolean instrumentOneFound = false;					boolean instrumentTwoFound = false;					while (it.hasNext()) {						ProductRef r = it.next();						Product p = r.getProduct();						String instrument = p.getInstrument();						if (instrumentOne.equals(instrument)) {							instrumentOneFound = true;						}						if (instrumentTwo.equals(instrument)) {							instrumentTwoFound = true;						}					}					assertTrue(instrumentOneFound && instrumentTwoFound);				}				{					// Check that there are 3 entries in storage.					Set<ProductRef> resultset = storage							.select(queryAllVersions);					assertTrue(resultset.size() == 3);				}			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// SIMPLE CONTEXT SAVE ----------------------------------------------------	/**	 * Save a product to a storage, and save it once more to the same storage.	 */	public void testSimpleContextSave() {		final String leaf_description_a = "leaf a";		final String leaf_description_b = "leaf b";		final int childIndex0 = 0;		final int childIndex1 = 1;		try {			ProductPool pool = getPool();			ProductStorage storage = new ProductStorage();			storage.register(pool);			/* Populate context */			Product leaf1 = new Product();			leaf1.setDescription(leaf_description_a);			ProductRef leaf_ref1 = new ProductRef(leaf1);			Product leaf2 = new Product();			leaf2.setDescription(leaf_description_b);			ProductRef leaf_ref2 = new ProductRef(leaf2);			ListContext parent = new ListContext();			parent.setDescription("Parent Description");			parent.getRefs().add(childIndex0, leaf_ref1);			parent.getRefs().add(childIndex1, leaf_ref2);			/* Save the context */			storage.save(parent);		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// TAG REUSE --------------------------------------------------------------	/**	 * In this test two products of the same tag are written to two pools. These	 * pools are re-used in another product storage. This test asserts that only	 * the tag from the first pool will be used.	 * 	 */	public void testSimpleMerging() {		final String tag = "mytag1";		final String creatorOne = "Creator1";		final String creatorTwo = "Creator2";		final String instrumentOne = "InstrumentOne";		final String instrumentTwo = "InstrumentTwo";		String firstProductInPoolOneUrn;		String secondProductInPoolOneUrn;		String firstProductInPoolTwoUrn;		// Populate storages.		try {			_LOGGER.info("TESTONE");			{				ProductStorage storage = new ProductStorage();				storage.register(getPool(1));				{					// Create a product and save it under an explicit tag.					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentOne);					firstProductInPoolOneUrn = storage.saveAs(p, tag).getUrn();				}				{					// Load product using given tag					ProductRef r;					r = storage.load(tag);					Product p = r.getProduct();					assertTrue(firstProductInPoolOneUrn.equals(r.getUrn()));					assertTrue(creatorOne.equals(p.getCreator()));				}				{					// Modify and save it again explicitly under the given tag.					// The tag should now be re-assigned to the new urn.					ProductRef r = storage.load(tag);					Product p = r.getProduct();					p.setCreator(creatorTwo);					secondProductInPoolOneUrn = storage.saveAs(p, tag).getUrn();				}			}			_LOGGER.info("TESTTWO");			{				ProductStorage storage = new ProductStorage();				storage.register(getPool(1));				ProductRef r;				_LOGGER.info("TESTTWO_A");				r = storage.load(tag);				_LOGGER.info("TESTTWO_B");				assertTrue(secondProductInPoolOneUrn.equals(r.getUrn()));				assertTrue(creatorTwo.equals(r.getProduct().getCreator()));			}			_LOGGER.info("TESTTHREE");			{				// Create tag information in a second pool				ProductStorage storageTwo;				storageTwo = new ProductStorage();				storageTwo.register(getPool(2));				{					// Create a product and save it under an explicit tag.					Product p = new TestProduct();					p.setCreator(creatorOne);					p.setInstrument(instrumentTwo);					firstProductInPoolTwoUrn = storageTwo.saveAs(p, tag)							.getUrn();				}				{					// Load product using given tag					ProductRef r;					r = storageTwo.load(tag);					Product p = r.getProduct();					assertTrue(firstProductInPoolTwoUrn.equals(r.getUrn()));					assertTrue(creatorOne.equals(p.getCreator()));				}			}			_LOGGER.info("TESTFOUR");			{				// Now, both pools have tag information.				// If a storage is created with both pools, only the tag info in				// the				// first pool is used.				// Create a new productstorage of the two pools, with pool #2				// last, and assert that the tag corresponds to the				// last product stored in				// pool#1.				ProductStorage storageMerged = new ProductStorage();				storageMerged.register(getPool(1));				storageMerged.register(getPool(2));				ProductRef r;				r = storageMerged.load(tag);				assertTrue(secondProductInPoolOneUrn.equals(r.getUrn()));				Product p = r.getProduct();				assertTrue(creatorTwo.equals(p.getCreator()));				assertTrue(instrumentOne.equals(p.getInstrument()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// IMPLICIT VERSIONING ----------------------------------------------------	/**	 * This tests the scenario where a user creates a product, and saves it to	 * the storage, but allows the system to provide an implicit version track.	 * Then further modifications and saves are monitored.	 */	public void testImplicitVersioning() {		final String descriptionOne = "Description 1";		final String descriptionTwo = "Description 2";		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			String urn, trackId;			{				// Create a product and save it				Product p = new TestProduct();				p.setDescription(descriptionOne);				ProductRef r = storage.save(p);				urn = r.getUrn();				trackId = r.getTrackId();				assertEquals(0, r.getVersion());			}			{				// Re-load product using urn				ProductRef r = storage.load(urn);				Product p = r.getProduct();				assertTrue(descriptionOne.equals(p.getDescription()));				assertEquals(trackId, r.getTrackId());			}			{				// Modify and save it again.				// This should be added as the latest version of the product.				ProductRef r = storage.load(urn);				Product p = r.getProduct();				p.setDescription(descriptionTwo);				storage.save(p);			}			{				// Get latest version				ProductRef r = storage.load(urn);				ProductRef r_latest = storage.getHead(r);				// Check version info and description				Product p_latest = r_latest.getProduct();				assertEquals(1, r_latest.getVersion());				assertEquals(trackId, r_latest.getTrackId());				assertTrue(descriptionTwo.equals(p_latest.getDescription()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * This tests the scenario where a user saves two instances of the same	 * product type. The instances should have separate version tracks.	 * 	 */	public void testImplicitVersioningTwoInstances() {		final String descriptionAOne = "Description A 1";		final String descriptionATwo = "Description A 2";		final String descriptionBOne = "Description B 1";		final String descriptionBTwo = "Description B 2";		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			String urnA;			{				// Create a product and save it under an implicit version.				Product p = new TestProduct();				p.setDescription(descriptionAOne);				_LOGGER.info("Description = " + p.getDescription());				urnA = storage.save(p).getUrn();			}			String urnB;			{				// Create another product of the same type				// and save it under another implicit version.				Product p = new TestProduct();				p.setDescription(descriptionBOne);				_LOGGER.info("Description = " + p.getDescription());				urnB = storage.save(p).getUrn();			}			// Re-load products using urn			{				ProductRef r = storage.load(urnA);				Product p = r.getProduct();				assertTrue(descriptionAOne.equals(p.getDescription()));			}			{				ProductRef r = storage.load(urnB);				Product p = r.getProduct();				assertTrue(descriptionBOne.equals(p.getDescription()));			}			{				// Modify and save product A again				// This should be added as the latest version of the product.				ProductRef r = storage.load(urnA);				Product p = r.getProduct();				p.setDescription(descriptionATwo);				storage.save(p);			}			{				// Modify and save product B again				// This should be added as the latest version of the product.				ProductRef r = storage.load(urnB);				Product p = r.getProduct();				p.setDescription(descriptionBTwo);				storage.save(p);			}			// Load latest versions of products			{				ProductRef r = storage.load(urnA);				ProductRef r_latest = storage.getHead(r);				Product p_latest = r_latest.getProduct();				assertTrue(descriptionATwo.equals(p_latest.getDescription()));			}			{				ProductRef r = storage.load(urnB);				ProductRef r_latest = storage.getHead(r);				Product p_latest = r_latest.getProduct();				assertTrue(descriptionBTwo.equals(p_latest.getDescription()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// ACCESS PRODUCTS --------------------------------------------------------	/**	 * This tests the scenario where a user creates a product, and saves it to	 * the storage with an explicit version track. Then further modifications	 * and saves are monitored.	 * 	 */	public void testAccessProduct() {		final String descriptionOne = "Description 1";		final String descriptionTwo = "Description 2";		String firstUrn;		String lastUrn;		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			{				// Create a product and save it.				Product p = new TestProduct();				p.setDescription(descriptionOne);				firstUrn = storage.save(p).getUrn();				_LOGGER.info("Description = " + p.getDescription());			}			{				// Load product again				ProductRef r;				r = storage.load(firstUrn);				Product p = r.getProduct();				assertTrue(descriptionOne.equals(p.getDescription()));			}			{				// Save another product under a different version track.				Product p = new TestProduct();				p.setDescription(descriptionOne);				storage.save(p);				_LOGGER.info("Description = " + p.getDescription());			}			{				// Modify and save the product according to the first version				// track				// again				ProductRef r = storage.load(firstUrn);				Product p = r.getProduct();				p.setDescription(descriptionTwo);				lastUrn = storage.save(p).getUrn();			}			{				ProductRef r = storage.load(firstUrn);				List<ProductRef> refs = storage.getVersions(r);				// List products stored				_LOGGER.info("saved versions for version track one = " + refs);				assertTrue(refs.size() == 2);				ProductRef firstRef = refs.get(0);				assertTrue(firstUrn.equals(firstRef.getUrn()));				ProductRef lastRef = refs.get(1);				assertTrue(lastUrn.equals(lastRef.getUrn()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * This tests the scenario where a user creates a context, and saves it to	 * the storage with an explicit version track. Then further modifications	 * and saves are monitored.	 * 	 */	public void testAccessContext() {		final String creatorOne = "creator 1";		final String creatorTwo = "creator 2";		String firstUrn;		String lastUrn;		ProductStorage storage = new ProductStorage();		storage.register(getPool());		try {			{				// Create a product and save it under an explicit version track.				Product p = new MapContext();				p.setCreator(creatorOne);				firstUrn = storage.save(p).getUrn();			}			{				// Load product				ProductRef r;				r = storage.load(firstUrn);				Product p = r.getProduct();				assertTrue(creatorOne.equals(p.getCreator()));			}			{				// Create a separate instance of the				// context and save it under a different version track.				Product p = new MapContext();				p.setCreator(creatorOne);				storage.save(p).getUrn();			}			{				// Modify and save the context belonging the first version track				// again				_LOGGER.info("firstUrn=" + firstUrn);				ProductRef r = storage.load(firstUrn);				Product p = r.getProduct();				if (p instanceof Context) {					_LOGGER.info("p is a context");				}				_LOGGER.info("Modifying context");				// p.setCreator(creatorTwo);				p.setDescription(creatorTwo);				_LOGGER.info("Context modified");				lastUrn = storage.save(p).getUrn();				_LOGGER.info("urn=" + lastUrn);			}			{				List<ProductRef> refs = storage.getVersions(storage						.load(firstUrn));				// List products stored				assertTrue("Expected 2 refs, got " + refs.size(),						refs.size() == 2);				ProductRef firstRef = refs.get(0);				assertTrue(firstUrn.equals(firstRef.getUrn()));				ProductRef lastRef = refs.get(1);				assertTrue(lastUrn.equals(lastRef.getUrn()));			}		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// SAVE HEAD ONLY ---------------------------------------------------------	/**	 * This tests verifies that only the current version of a product (context	 * in this case) is saved into a pool while the previous versions are not.	 */	public void testSaveHeadOnly() {		try {			ProductPool ppTmp = getPool(1);			ProductStorage psTmp = new ProductStorage();			psTmp.register(ppTmp);			Product p = new Product();			MapContext mc = new MapContext();			mc.getRefs().put("p1", new ProductRef(p));			psTmp.save(mc);			mc.setCreator("c1");			psTmp.save(mc);			mc.setCreator("c2");			/*			 * System.out.println("2:\n" + psTmp.getVersioningInfo()); 2:			 * 			 * Tag | URN			 * 			 * 			 * Version track: Unknown_1			 * 			 * Assoc Type: herschel.ia.pal.MapContext,Unknown Version | URN 0 |			 * urn:simple.testpool_1:herschel.ia.pal.MapContext:0 1 |			 * urn:simple.testpool_1:herschel.ia.pal.MapContext:1			 * 			 * 			 * Version track: Unknown_0			 * 			 * Assoc Type: herschel.ia.dataset.Product,Unknown Version | URN 0 |			 * urn:simple.testpool_1:herschel.ia.dataset.Product:0			 * 			 */			ProductPool pp = getPool(0);			ProductStorage ps = new ProductStorage();			ps.register(pp);			ProductRef pRef = ps.save(mc);			// ProductRef pRef = ps.saveHeadOnly(mc);			List<ProductRef> pRefVersions = ps.getVersions(pRef);			// System.out.println(pRefVersions.size());			if (pRefVersions.size() != 1) {				fail("Cloned previous versions.");			}			/*			 * System.out.println("3:\n" + ps.getVersioningInfo()); 3:			 * 			 * Tag | URN			 * 			 * 			 * Version track: Unknown_1			 * 			 * Assoc Type: herschel.ia.pal.MapContext,Unknown Version | URN 0 |			 * urn:simple.testpool_0:herschel.ia.pal.MapContext:0			 * 			 * 			 * Version track: Unknown_0			 * 			 * Assoc Type: herschel.ia.dataset.Product,Unknown Version | URN 0 |			 * urn:simple.testpool_0:herschel.ia.dataset.Product:0			 */		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	// SYNCHRONIZATION --------------------------------------------------------	/**	 * This tests verifies synchronization of versioning information among	 * different storages.	 */	public void testSynchronization() {		try {			// Reload versioning and tags information before each operation			ProductStorage.setSharedMode(true);			final String tagA = "tagA";			final String tagB = "tagB";			final String tagC = "tagC";			final Query query = new Query("1");			ProductPool pool = getPool();			ProductStorage storage1 = new ProductStorage();			ProductStorage storage2 = new ProductStorage();			storage1.register(pool);			storage2.register(pool);			Product p1 = new Product();			ProductRef ref = storage1.save(p1);			storage1.setTag(tagA, ref.getUrn());			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());			Product p2 = storage2.load(tagA).getProduct();			assertEquals(p1, p2);			assertTrue(storage1.tagExists(tagA));			assertTrue(storage2.tagExists(tagA));			storage1.setTag(tagB, ref.getUrn());			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());			p2 = storage2.load(tagB).getProduct();			assertEquals(p1, p2);			assertTrue(storage2.tagExists(tagB));			assertTrue(storage1.tagExists(tagB));			ref = storage1.saveAs(new Product(), tagC);			assertTrue(storage1.tagExists(tagC));			assertTrue(storage2.tagExists(tagC));			assertEquals(storage1.select(query).size(), 2);			assertEquals(storage2.select(query).size(), 2);			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());			storage2.remove(ref.getUrn());			assertFalse(storage1.tagExists(tagC));			assertFalse(storage2.tagExists(tagC));			assertEquals(storage1.select(query).size(), 1);			assertEquals(storage2.select(query).size(), 1);			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());			storage1.removeTag(tagA);			assertFalse(storage1.tagExists(tagA));			assertFalse(storage2.tagExists(tagA));			assertEquals(storage1.select(query).size(), 1);			assertEquals(storage2.select(query).size(), 1);			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());			storage1.removeTag(tagB);			assertFalse(storage1.tagExists(tagB));			assertFalse(storage2.tagExists(tagB));			assertEquals(storage1.select(query).size(), 1);			assertEquals(storage2.select(query).size(), 1);			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());			storage1.remove(storage1.select(query).iterator().next().getUrn());			assertEquals(storage1.select(query).size(), 0);			assertEquals(storage2.select(query).size(), 0);			// assertEquals(storage1.getVersioningInfo(),			// storage2.getVersioningInfo());		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		} finally {			ProductStorage.setSharedMode(false);		}	}	// PERFORMANCE --------------------------------------------------------	// Wrapper pool that counts number of calls to each method	class CounterPool extends AbstractProductPool {		private ProductPool _pool = null;		private Map<String, Integer> _counts = new LinkedHashMap<String, Integer>();		CounterPool(ProductPool pool) {			_pool = pool;			_counts.put("save", 0);			_counts.put("load", 0);			_counts.put("loadProduct", 0);			_counts.put("meta", 0);			_counts.put("exists", 0);			_counts.put("remove", 0);		}		/** Resets all the counts. */		public void resetCounts() {			for (Map.Entry<String, Integer> entry : _counts.entrySet()) {				entry.setValue(0);			}		}		/** Returns the number of calls to the given method. */		public int getCount(String methodName) {			return _counts.get(methodName);		}		public String getId() {			return _pool.getId();		}		public Set<Class<? extends Product>> getProductClasses()		throws IOException, GeneralSecurityException {			return _pool.getProductClasses();		}		public ProductRef getLastVersion(ProductRef ref)		throws IOException, GeneralSecurityException {			return _pool.getLastVersion(ref);		}		public List<ProductRef> getVersions(ProductRef ref)		throws IOException, GeneralSecurityException {			return _pool.getVersions(ref);		}		public boolean isAlive() {			return _pool.isAlive();		}		public String save(ProductRef ref) throws IOException,				GeneralSecurityException {			increment("save");			return _pool.save(ref);		}		// public ProductRef load(String urn)		// throws IOException, GeneralSecurityException {		// return _pool.load(urn);		// }		public Product loadProduct(String urn)		throws IOException, GeneralSecurityException {			increment("load"); // previous load is now loadProduct			return _pool.loadProduct(urn);		}		public Map<String, Object> loadDescriptors(String urn)				throws IOException, GeneralSecurityException {			return _pool.loadDescriptors(urn);		}		public MetaData meta(String urn)		throws IOException, GeneralSecurityException {			increment("meta");			return _pool.meta(urn);		}		public boolean exists(String urn) throws IOException,				GeneralSecurityException {			increment("exists");			return _pool.exists(urn);		}		public void remove(String urn) throws IOException,				GeneralSecurityException {			increment("remove");			_pool.remove(urn);		}		public Set<ProductRef> select(StorageQuery query) throws IOException,				GeneralSecurityException {			return _pool.select(query);		}		public Set<ProductRef> select(StorageQuery query,				Set<ProductRef> results) throws IOException,				GeneralSecurityException {			return _pool.select(query, results);		}		public void acquireLock() throws IOException, GeneralSecurityException {			_pool.acquireLock();		}		public boolean isLockAcquired() {			return _pool.isLockAcquired();		}		public boolean isLocked() throws IOException, GeneralSecurityException {			return _pool.isLocked();		}		public void releaseLock() throws IOException, GeneralSecurityException {			_pool.releaseLock();		}		/** String representation of the pool. */		public String toString() {			return _counts.toString();		}		/** Increments the counter for the given method. */		private void increment(String methodName) {			_counts.put(methodName, _counts.get(methodName) + 1);		}	}	/**	 * This tests verifies that the calls to key methods in a pool remains as	 * expected.	 */	public void testCountCalls() {		try {			// Pool and storage initializations			StorageQuery queryAll = new AttribQuery(Product.class, "p", "1");			CounterPool poolA = new CounterPool(getPool(1));			CounterPool poolB = new CounterPool(getPool(2));			ProductStorage storageA = new ProductStorage();			ProductStorage storageB = new ProductStorage();			ProductStorage storageC = new ProductStorage();			storageA.register(poolA);			storageB.register(poolB);			storageB.register(poolA); // read-only			storageC.register(poolA);			String tag = "tag";			// Nomenclature:			// TP = TagsProduct			// PV = Previous versions			// checkCount: save, load, meta, exists, remove			// Save operation			Product p = new Product();			storageA.saveAs(p, tag);			checkCount(poolA, 2, 0, 0, 0, 0); // 2 save (with TP)			storageA.save(p);			checkCount(poolA, 1, 0, 0, 0, 0); // 1 save			storageA.save(p);			checkCount(poolA, 1, 0, 0, 0, 0); // 1 save			storageA.save(p);			checkCount(poolA, 1, 0, 0, 0, 0); // 1 save			storageB.save(p);			checkCount(poolA, 0, 0, 0, 0, 0);			checkCount(poolB, 1, 0, 0, 0, 0); // 1 save			storageB.save(p);			checkCount(poolA, 0, 0, 0, 0, 0);			checkCount(poolB, 1, 0, 0, 0, 0); // 1 save			// Load operation			storageA.load(tag).getProduct();			// TODO: meta allowed in load while providing BACKWARDS			// COMPATIBILITY for versioning in metadata			checkCount(poolA, 0, 1, 1, 2, 0); // 1 load, 2 exists (1 in load,												// 1 in getProduct)			storageB.load(tag).getProduct();			checkCount(poolA, 0, 2, 2, 2, 0); // 2 load (with TP), 2 exists (1												// in load, 1 in getProduct)			checkCount(poolB, 0, 0, 1, 2, 0); // 2 exists (1 in load, 1 in												// getProduct)			// Meta operation			ProductRef ref = storageA.save(new Product());			poolA.resetCounts();			poolA.meta(ref.getUrn());			checkCount(poolA, 0, 0, 1, 1, 0); // 1 meta, 1 exists			// Exists operation			storageA.exists(ref.getUrn());			checkCount(poolA, 0, 0, 0, 1, 0); // 1 exists			// Remove operation			storageA.remove(ref.getUrn());			checkCount(poolA, 0, 0, 0, 1, 1); // 1 exists, 1 remove			// Select operation			for (int i = 0; i < 5; i++) {				storageA.save(new MapContext());			}			poolA.resetCounts();			storageA.select(queryAll);			checkCount(poolA, 0, 0, 0, 0, 0); // only returns refs!			storageC.select(queryAll);			checkCount(poolA, 0, 0, 0, 0, 0); // no meta query involved!			storageC.select(queryAll);			checkCount(poolA, 0, 0, 0, 0, 0); // again the same		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		}	}	/**	 * Checks if the number of operations in the pool is at most that specified.	 */	private void checkCount(CounterPool pool, int maxSave, int maxLoad,			int maxMeta, int maxExists, int maxRemove) {		checkCount(pool, maxSave, "save");		checkCount(pool, maxLoad, "load");		checkCount(pool, maxMeta, "meta");		checkCount(pool, maxExists, "exists");		checkCount(pool, maxRemove, "remove");		pool.resetCounts();	}	/**	 * Checks if the number of operations in the pool is at most that specified.	 */	private void checkCount(CounterPool pool, int maxCount, String methodName) {		int count = pool.getCount(methodName);		assertTrue("Failed count for " + methodName + ": maximum expected was "				+ maxCount + ", but got " + count, count <= maxCount);	}	// SPRs --------------------------------------------------------	// Doesn't make sense after the removal of versioning metadata	// public void testSpr3620() throws IOException, GeneralSecurityException {	//	// final String metaVersionTrack = "versionTrack";	// final String metaVersionNumber = "versionNumber";	//	// ProductStorage storage = new ProductStorage();	// ProductPool pool = getPool();	// storage.register(pool);	//	// Product p1 = new Product();	// assertFalse(p1.getMeta().containsKey(metaVersionTrack));	// assertFalse(p1.getMeta().containsKey(metaVersionNumber));	//        	// storage.save(p1);	// assertTrue(p1.getMeta().containsKey(metaVersionTrack));	// assertTrue(p1.getMeta().containsKey(metaVersionNumber));	//	// Product p2 = new Product(p1);	// assertFalse(p2.getMeta().containsKey(metaVersionTrack));	// assertFalse(p2.getMeta().containsKey(metaVersionNumber));	//	// storage.save(p2);	// assertTrue(p2.getMeta().containsKey(metaVersionTrack));	// assertTrue(p2.getMeta().containsKey(metaVersionNumber));	//	// assertFalse(p1.getMeta().get(metaVersionTrack).equals(	// p2.getMeta().get(metaVersionTrack)));	// }	public void testProblemBuild1413() {		try {			// There were problems with this code in build 1413			ProductStorage.setSharedMode(true);			ProductStorage storage = new ProductStorage();			Product product = new Product();			storage.register(getPool());			storage.save(product);			storage.save(product);			storage.save(product); // the 3rd time an IOException was raised		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		} finally {			ProductStorage.setSharedMode(false);		}	}	public void testPoolWithoutVersioning() {		testPoolWithoutVersioning(false);		testPoolWithoutVersioning(true);	}	private void testPoolWithoutVersioning(boolean sharedMode) {		try {			// Set the shared mode			ProductStorage.setSharedMode(sharedMode);			// Test reading a pool whithout versioning information			ProductPool poolA = getPool(1);			Product product1 = new Product();			String urn = poolA.save(product1);			ProductStorage storageA = new ProductStorage();			storageA.register(poolA);			Product product2 = storageA.load(urn).getProduct();			assertEquals(product1, product2);			// Now save the product in another pool			ProductPool poolB = getPool(2);			ProductStorage storageB = new ProductStorage();			storageB.register(poolB);			ProductRef ref = storageB.save(product2);			Product product3 = ref.getProduct();			assertEquals(product3, product2);		} catch (IOException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (GeneralSecurityException e) {			fail("Following exception was raised " + StackTrace.trace(e));		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		} finally {			ProductStorage.setSharedMode(false);		}	}	// Specific tests for SPRs	public void testSpr4147() {		// Check that only tags in the writable pool are taken into account		try {			String tag = "oneTag";			ProductPool pool1 = getPool(1);			ProductPool pool2 = getPool(2);			ProductPool pool3 = getPool(3);			ProductStorage storage1 = new ProductStorage(pool1);			ProductStorage storage2 = new ProductStorage(pool2);			ProductStorage storage3 = new ProductStorage(pool3, pool2, pool1);			ProductStorage storage4 = new ProductStorage(pool1, pool2);			ProductStorage storage5 = new ProductStorage(pool2, pool1);			ProductRef ref1 = storage1.saveAs(new Product(), tag);			ProductRef ref2 = storage2.saveAs(new Product(), tag);			assertTrue(storage1.tagExists(tag));			assertTrue(storage2.tagExists(tag));			assertFalse(storage3.tagExists(tag));			assertTrue(storage4.tagExists(tag));			assertTrue(storage5.tagExists(tag));			assertEquals(ref1, storage1.getUrnFromTag(tag));			assertEquals(ref2, storage2.getUrnFromTag(tag));			assertEquals(ref1, storage4.getUrnFromTag(tag));			assertEquals(ref2, storage5.getUrnFromTag(tag));			storage1.removeTag(tag);			assertFalse(storage1.tagExists(tag));			assertTrue(storage2.tagExists(tag));			assertFalse(storage3.tagExists(tag));			assertFalse(storage4.tagExists(tag));			assertTrue(storage5.tagExists(tag));		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		} finally {			ProductStorage.setSharedMode(false);		}	}	public void testSpr4151() {		try {			ProductPool pool1 = getPool(1);			ProductPool pool2 = getPool(2);			ProductPool pool3 = getPool(3);			ProductStorage storage1 = new ProductStorage();			ProductStorage storage2 = new ProductStorage();			ProductStorage storage3 = new ProductStorage();			storage1.register(pool1);			storage1.register(pool2);			storage2.register(pool2);			storage2.register(pool1);			storage3.register(pool3);			storage3.register(pool1);			Product p1 = new Product();			p1.setModelName("1st model");			ProductRef ref1A = storage1.save(p1);			p1.setModelName("2nd model");			ProductRef ref1B = storage1.save(p1);			p1.setCreator("Test Engineer");			ProductRef ref2 = storage2.save(p1);			// storage1 => pool1 hides pool2			// storage2 => pool2 hides pool1			// storage3 => pool3 does not hide pool1			List<ProductRef> versions1 = storage1.getVersions(ref1A);			List<ProductRef> versions2 = storage2.getVersions(ref1A);			List<ProductRef> versions3 = storage3.getVersions(ref1A);			ProductRef lastVersion1 = storage1.getHead(ref1A);			ProductRef lastVersion2 = storage2.getHead(ref1A);			ProductRef lastVersion3 = storage3.getHead(ref1A);			assertEquals(2, versions1.size());			assertEquals(1, versions2.size());			assertEquals(2, versions3.size());			assertEquals(ref1A, versions1.get(0));			assertEquals(ref1B, versions1.get(1));			assertEquals(ref2, versions2.get(0));			assertEquals(ref1A, versions3.get(0));			assertEquals(ref1B, versions3.get(1));			assertEquals(ref1B, lastVersion1);			assertEquals(ref2, lastVersion2);			assertEquals(ref1B, lastVersion3);		} catch (Exception e) {			fail("Following exception was raised " + StackTrace.trace(e));		} finally {			ProductStorage.setSharedMode(false);		}	}}